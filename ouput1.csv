Domain name,User Inputs,description -> semi-formal,semi-formal -> BC domain,Domain prompt (bcdomain2asp),NL -> shorthand BC (nl2bc),shorthand BC -> BC (sh2bc),BC -> ASP (bc2asp),NL query -> ASP query,All responses/All responses without intermediate BC,BC Program,ASP Program
lifting prompts,"An object is on a table, but if the table ends are not equal then it will fall off. Provide the relevant commonsense knowledge.
----------------------------------------------------------------------



% The object is on the table initially at time 0.
% The object is not on the table at time 1.

","Given a description of a problem, write commonsense knowledge about the domain that we would expect. These represent logical constraints in the problem.

For example, a task about moving objects would involve some knowledge about what is required to move, what the effect of moving an object does, such as the location of the object changing or its previous location now being empty. 

These restrictions and effects are dependent on the context of the problem. Here we list some example problems and extract commonsense knowledge.

Problem 1
Description:
A monkey wants to get a bunch of bananas hanging from the ceiling. He can reach the bananas by first pushing a box to the empty place under the bananas and then climbing on top of the box. The task is to come up with a plan for retrieving the bananas.
Some things to consider are the monkey, the bananas, the box, the location of objects, and the monkey's ability to move and push the box. Provide the relevant commonsense knowledge. Only use the terminology in the hint to write the commonsense knowledge.

Hint:
There are two main types of things: ""things"" and ""location"".

monkey, bananas, and box are things.
l1, l2, and l3 are locations.

Fluents:
A (thing)'s location is a simple fluent (location).
Having bananas is a simple fluent (boolean).
Being on the box are simple fluents (boolean).

Actions:
walk to a (location)
push box to a (location)
climb on
climb off
grasp bananas

Commonsense knowledge (do not provide any extra knowledge that is not included in the description):
% The location of the bananas is where the monkey is if the monkey has bananas.
% The location of the monkey is where the box is if the monkey is on the box.
% Walking to a location causes the monkey’s location to change.
% Walking is not permissible to a location if the monkey is already in that location
% Walking is not permissible if the monkey is on the box.
% Pushing the box to a location causes the location of the box to move.
% Pushing the box to a location causes the location f the monkey to move.
% Pushing the box is not permissible to a location if the monkey is at that location
% Pushing the box is not permissible if the monkey is on the box.
% Pushing the box is not permissible if the location of the monkey is not the same as the location of the box.
% Climbing on the box causes the monkey to be on the box.
% Climbing on the box is not permissible if the monkey is already on the box.
% Climbing on the box is not permissible if the location of the monkey is not the same as the box.
% Climbing off of the box causes the monkey to not be on the box.
% Climbing off of the box is not permissible if the monkey is not on the box.
% Grasping the bananas causes the monkey to have the bananas.
% Grasping the bananas is not permissible if the monkey already has the bananas.
% Grasping the bananas is not permissible if the monkey is not on the box.
% Grasping the bananas is not permissible if the location of the monkey is not the same as the location of the bananas.
% It is not permissible to both walk to a location and push the box to a location.
% It is not permissible to both walk to a location and climb on the box.
% It is not permissible to both push the box to a location and climb on the box.
% It is not permissible to both climb off of the box and grasp the bananas.

Problem 2:
Description:
An object is on a table, but if the table ends are not equal then it will fall off. Provide the relevant commonsense knowledge.

Hint:
There are two main types of things: ""end"" and ""height"".

leftend and rightend are ends.
low and high are heights.

Fluents:
The level of an (end) is an inertial fluent (height).
The object being on the table is an inertial fluent.

Actions:
Lift and (end).
Commonsense knowledge (do not provide any extra knowledge that is not included in the description):

% The object is on the table if the level of the leftend is the same as the level of the rightend.
% The object is not on the table if the level of the leftend is not the same as the level of the rightend.
% Lifting an end causes the level of that end to change.
% Lifting an end is not permissible if the level of that end is already high.
% Lifting an end is not permissible if the object is on the table.
% It is not permissible to lift both ends at the same time.","Action language BC specifies the syntax of the domain in the form of sorts, objects, variables, and constants. 

A sort is a named set of elements which is used to specify the domain of each constant and variable. First the sort is declared
using a sort declaration statement and, later, is defined by adding objects to it in an object declaration statement.

Sort declaration:
:- sorts
    int;
    box.

This declares the domains: int, and box.

An object is a value in a sort which a constant can take. It is also used
in parameter lists to construct nested objects and sets of constants. 

Object declaration:
:- objects
    1..3 :: int;
    o(int, int) :: box.

This declares 1,2, and 3 as objects within int, and the objects:
o(1, 1), o(1, 2), o(1, 3),
o(2, 1), o(2, 2), o(2, 3),
o(3, 1), o(3, 2), and o(3, 3),
as values within box.

A variable is a placeholder symbol which will be replaced with each object in its domain during grounding.

Variable declaration:
:- variables
    I, I1, I2 :: int;
    B, B1, B2 :: box.
This declares the variables I, I1, and I2 over the objects within int, and variables B, B1, and B2 range over the objects within box.

Constant symbols are the basic components of multivalued formulas. Similar to object symbols, constants are defined within a constant declaration statement and have a base identifier, an optional list of parameter sort, and a sort which makes up the constant’s domain. In addition, they may have a constant declaration type, such as ""action"", ""simpleFluent"", and ""inertialFluent"". Inertial fluents are used for constants whose value persists through time unless affected otherwise.
Constant declaration:
:- constants
    p(int) :: inertialFluent;
    move(box) :: action.
This declares the inertial fluent p which takes an int argument, and the action move, which takes a box argument.

Given some knowledge about a domain, produce the sorts, objects, variables, and constants for the action language BC. 

Problem 1
Problem description:
A monkey wants to get a bunch of bananas hanging from the ceiling. He can reach the bananas by first pushing a box to the empty place under the bananas and then climbing on top of the box.

Hint:
There are three main types of things: ""monkey"", ""thing"" and ""location"".
""thing"" includes ""monkey"".

monkey, bananas, and box are things.
l1, l2, and l3 are locations.

Fluents:
A (thing)'s location is a simple fluent (location).
Having bananas is a simple fluent (boolean).
Being on the box are simple fluents (boolean).

Actions:
walk to a (location)
push box to a (location)
climb on
climb off
grasp bananas

Knowledge:
% The location of the bananas is where the monkey is if the monkey has bananas.
% The location of the monkey is where the box is if the monkey is on the box.
% Walking to a location causes the monkey’s location to change.
% Walking is not permissible to a location if the monkey is already in that location
% Walking is not permissible if the monkey is on the box.
% Pushing the box to a location causes the location of the box to move.
% Pushing the box to a location causes the location f the monkey to move.
% Pushing the box is not permissible to a location if the monkey is at that location
% Pushing the box is not permissible if the monkey is on the box.
% Pushing the box is not permissible if the location of the monkey is not the same as the location of the box.
% Climbing on the box causes the monkey to be on the box.
% Climbing on the box is not permissible if the monkey is already on the box.
% Climbing on the box is not permissible if the location of the monkey is not the same as the box.
% Climbing off of the box causes the monkey to not be on the box.
% Climbing off of the box is not permissible if the monkey is not on the box.
% Grasping the bananas causes the monkey to have the bananas.
% Grasping the bananas is not permissible if the monkey already has the bananas.
% Grasping the bananas is not permissible if the monkey is not on the box.
% Grasping the bananas is not permissible if the location of the monkey is not the same as the location of the bananas.
% It is not permissible to both walk to a location and push the box to a location.
% It is not permissible to both walk to a location and climb on the box.
% It is not permissible to both push the box to a location and climb on the box.
% It is not permissible to both climb off of the box and grasp the bananas.

BC domain syntax:
:- sorts
    thing >> monkey;
    location.
:- objects
    monkey,bananas,box :: thing;
    l1,l2,l3 :: location.
:- variables
    Loc, Loc1, Loc2 :: location;
    Bool, Bool1, Bool2 :: boolean.
:- constants
    loc(thing) :: simpleFluent(location);
    hasBananas,onBox :: simpleFluent;
    walk(location) :: action;
    pushBox(location) :: action;
    climbOn :: action;
    climbOff :: action;
    graspBananas :: action.


Problem 2
Problem description:
An object is on a table, but if the table ends are not equal then it will fall off. Provide the relevant commonsense knowledge.

Hint:
There are two main types of things: ""end"" and ""height"".

leftend and rightend are ends.
low and high are heights.

Fluents:
The level of an (end) is an inertial fluent (height).
The object being on the table is an inertial fluent.

Actions:
Lift and (end).

Knowledge:
% The object is on the table if the level of the leftend is the same as the level of the rightend.
% The object is not on the table if the level of the leftend is not the same as the level of the rightend.
% Lifting an end causes the level of that end to change.
% Lifting an end is not permissible if the level of that end is already high.
% Lifting an end is not permissible if the object is on the table.
% It is not permissible to lift both ends at the same time.

BC domain syntax:

:- sorts
    end;
    height.
:- objects
    leftend,rightend :: end;
    low,high :: height.
:- variables
    E, E1, E2 :: end;
    H, H1, H2 :: height.
:- constants
    level(end) :: inertialFluent(height);
    onTable :: inertialFluent;
    lift(end) :: action.","The programming language BC is an action language which has two kinds of constants, a fluent constant and an action constant. Answer Set Programming (ASP) is a logic programming paradigm. Given a domain specification in BC, generate ASP code which represents the supersorts (if applicable), sorts, choice rule for every fluent constant, choice rule for every action constant, inertial rules, and the uniqueness/existence constraint for each atom.
s_boolean(true;false) represents the boolean values true and false and is always used.
Write the constraints according to the given domains into BC:

Program 1:

Domain:
:- sorts
    loc >> block;
    block_w_none >> block;
    machine;
    gripper.

:- objects
    table :: loc;
    b1, b2, b3, b4 :: block;
    none :: block_w_none;
    m1, m2 :: machine;
    g1, g2, g3 :: gripper.

:- constants
    loc(block) :: inertialFluent(loc);
    gripped :: inertialFluent(block_w_none);
    in_tower(block) :: sdFluent;
    move(block, loc) :: action.

:-variables
    B, B1, B2 :: block;
    B_none :: block_w_none;
    L, L1 :: loc.


Generated constraints:

% supersorts
s_loc(B) :- s_block(B).
s_block_w_none :- s_block(B).

% sorts
s_boolean(true;false).
s_block_w_none(none).

s_loc(table).
s_block(b1;b2;b3;b4).
s_machine(m1;m2).
s_gripper(g1;g2).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loc(B,V),0)} :- s_block(B), s_loc(V).
{holds(gripped(V),0)} :- s_block_w_none(V).
{holds(in_tower(B,V),0)} :- s_block(B), s_boolean(V).


% choice rule {i:a} for every action constant a and every i < l
{occurs(move(B,L),T_step)} :- s_block(B), s_loc(L), timestep(T_step).

% Inertia

{holds(loc(B,V),T_step+1)} :-holds(loc(B,V),T_step), timestep(T_step).
{holds(gripped(V),T_step+1)} :-holds(gripped(V),T_step), timestep(T_step).
{holds(in_tower(B,V),T_step+1)} :-holds(in_tower(B,V),T_step), timestep(T_step).


% existence and uniqueness of value constraint

:- not {holds(loc(B,V),T_step): s_loc(V)}=1, s_block(B), timestep(T_step).
:- not {holds(gripped(V),T_step): s_block_w_none(V)}=1, timestep(T_step).
:- not {holds(in_tower(B,V),T_step): s_boolean(V)}=1, s_block(B), timestep(T_step).

Program 2:

Domain:
:- sorts
    end;
    height.
:- objects
    leftend,rightend :: end;
    low,high :: height.
:- variables
    E, E1, E2 :: end;
    H, H1, H2 :: height.
:- constants
    level(end) :: inertialFluent(height);
    onTable :: inertialFluent;
    lift(end) :: action.

Generated constraints:

% supersorts
% No supersorts in this domain

% sorts
s_boolean(true;false).
s_end(leftend;rightend).
s_height(low;high).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(level(E,V),0)} :- s_end(E), s_height(V).
{holds(onTable(V),0)} :- s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(lift(E),T_step)} :- s_end(E), timestep(T_step).

% Inertia
{holds(level(E,V),T_step+1)} :-holds(level(E,V),T_step), timestep(T_step).
{holds(onTable(V),T_step+1)} :-holds(onTable(V),T_step), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(level(E,V),T_step): s_height(V)}=1, s_end(E), timestep(T_step).
:- not {holds(onTable(V),T_step): s_boolean(V)}=1, timestep(T_step).","A program in BC consists of causal rules of the following 2 forms where their readings are shown after ""%"".
There are two kinds of constants, a fluent constant and an action constant. An  atom is of the form f=v, where f is a fluent constant, and v is an element of its domain. A fluent which has no argument, such as ""hasGas"" is assumed to be boolean. 

An expression of the form:
A_0 if A_1 & A_2 & ... & A_n

where A_i are atoms, expresses the static law that A_0 is true if the conjunction of A_1 & ... & A_n is true.

Example:
% The location of a person is the same as the car if the person is in the car.
loc(person)=L if inCar & loc(car)=L.
Note that the head of the rule (loc(person)=L in the example), must be only a single atom. So the following rule is not valid:
loc(person)=loc(car) if inCar.

An expression of the form:
F causes G if H

where  F is an action, G is an atom and H is a conjunction of atoms, expresses that action F causes G to be true if H is true. 

It also stands for the fluent dynamic law:
caused G after F & H
which expresses that atom G is causes after action F and atom H are true.

Example:
open(D) causes opened(D) if available(D).

Here are some common ways to write rules.

An expression of the form:
impossible A_1 & A_2 & ... & A_n

where A_i are atoms, is used to express that the conjunction of A_i is impossible.

Example:
impossible hasbrother(C) & ~hasSibling(C).
(note that impossible must only have conjunction (&), and cannot contain ""if"")
The form ""impossible A_1 if ..."" is incorrect while ""impossible A_1 & ..."" is correct.

For example, the following is incorrect:
impossible hasbrother(C) if ~hasSibling(C).

An expression of the form:
nonexecutable a_1 & ... & a_n if A_1 & A_2 & ... & A_m.

where a_i are actions and A_i are atoms, is used to express that an action cannot be executed if the conjunction of A_i is true.

Examples:
% It is not permissible to drive a car if it has no gas.
nonexecutable driveCar if ~hasGas.
% It is not permissible to lift an object if it is heavy.
nonexecutable lift(object) if heavy(object).

Example:
default onTable(B) if block(B). 

Examples
default door(open) if door(unlocked) after push(door).

In general, if something cannot be true, then we use ""impossible"" when writing the rules, but if instead we want to assert something is not true, then we use the negation (~). For example, if it is impossible for an object to be on the table and under it, we might write ""impossible onTable(object) & underTable(object)."", but express that if it rains outside the ground is not wet as ""~groundWet if noRain"".
Additionally, ""impossible"" is reserved only for fluents, while ""nonexecutable"" is only reserved for actions.

Here is an example representation.
Problem 1:
:- sorts
    thing;
    location.
:- objects
    monkey,bananas,box :: thing;
    l1,l2,l3 :: location.
:- variables
    Loc, Loc1, Loc2 :: location;
    Bool, Bool1, Bool2 :: boolean.
:- constants
    loc(thing) :: simpleFluent(location);
    hasBananas,onBox :: simpleFluent;
    walk(location) :: action;
    pushBox(location) :: action;
    climbOn :: action;
    climbOff :: action;
    graspBananas :: action.

Represent the following constraints:
% The location of the bananas is where the monkey is if the monkey has bananas.
% The location of the monkey is where the box is if the monkey is on the box.
% The monkey cannot be in two places at once.
% Walking to a location causes the monkey’s location to change.
% Walking is not permissible to a location if the monkey is already in that location
% Walking is not permissible if the monkey is on the box.
% Pushing the box to a location causes the location of the box to move.
% Pushing the box to a location causes the location of the monkey to move.
% Pushing the box is not permissible to a location if the monkey is at that location
% Pushing the box is not permissible if the monkey is on the box.
% Pushing the box is not permissible if the location of the monkey is not the same as the location of the box.
% Climbing on the box causes the monkey to be on the box.
% Climbing on the box is not permissible if the monkey is already on the box.
% Climbing on the box is not permissible if the location of the monkey is not the same as the box.
% Climbing off of the box causes the monkey to not be on the box.
% Climbing off of the box is not permissible if the monkey is not on the box.
% Grasping the bananas causes the monkey to have the bananas.
% Grasping the bananas is not permissible if the monkey already has the bananas.
% Grasping the bananas is not permissible if the monkey is not on the box.
% Grasping the bananas is not permissible if the location of the monkey is not the same as the location of the bananas.
% It is not permissible to both walk to a location and push the box to a location.
% It is not permissible to both walk to a location and climb on the box.
% It is not permissible to both push the box to a location and climb on the box.
% It is not permissible to both climb off of the box and grasp the bananas.

Constraints (only use fluents and actions specified for the problem):
% The location of the bananas is where the monkey is if the monkey has bananas.
loc(bananas)=L if hasBananas & loc(monkey)=L.

% The location of the monkey is where the box is if the monkey is on the box.
loc(monkey)=L if onBox & loc(box)=L.

% The monkey cannot be in two places at once.
impossible loc(monkey) = L1 & loc(monkey)=L2 & L1\=L2.

% Walking to a location causes the monkey’s location to change.
walk(L) causes loc(monkey)=L.

% Walking is not permissible to a location if the monkey is already in that location
nonexecutable walk(L) if loc(monkey)=L.

% Walking is not permissible if the monkey is on the box.
nonexecutable walk(L) if onBox.

% Pushing the box to a location causes the location of the box to move.
pushBox(L) causes loc(box)=L.

% Pushing the box to a location causes the location of the monkey to move.
pushBox(L) causes loc(monkey)=L.

% Pushing the box is not permissible to a location if the monkey is at that location
nonexecutable pushBox(L) if loc(monkey)=L.

% Pushing the box is not permissible if the monkey is on the box.
nonexecutable pushBox(L) if onBox.

% Pushing the box is not permissible if the location of the monkey is not the same as the location of the box.
nonexecutable pushBox(L) if loc(monkey)\=loc(box).

% Climbing on the box causes the monkey to be on the box.
climbOn causes onBox.

% Climbing on the box is not permissible if the monkey is already on the box.
nonexecutable climbOn if onBox.

% Climbing on the box is not permissible if the location of the monkey is not the same as the box.
nonexecutable climbOn if loc(monkey)\=loc(box).

% Climbing off of the box causes the monkey to not be on the box.
climbOff causes ~onBox.

% Climbing off of the box is not permissible if the monkey is not on the box.
nonexecutable climbOff if ~onBox.

% Grasping the bananas causes the monkey to have the bananas.
graspBananas causes hasBananas.

% Grasping the bananas is not permissible if the monkey already has the bananas.
nonexecutable graspBananas if hasBananas.

% Grasping the bananas is not permissible if the monkey is not on the box.
nonexecutable graspBananas if ~onBox.

% Grasping the bananas is not permissible if the location of the monkey is not the same as the location of the bananas.
nonexecutable graspBananas if loc(monkey)\=loc(bananas).

% It is not permissible to both walk to a location and push the box to a location.
nonexecutable walk(L) & pushBox(L).

% It is not permissible to both walk to a location and climb on the box.
nonexecutable walk(L) & climbOn.

% It is not permissible to both push the box to a location and climb on the box.
nonexecutable pushBox(L) & climbOn.

% It is not permissible to both climb off of the box and grasp the bananas.
nonexecutable climbOff & graspBananas.

Problem 2:
Given the following domain:
:- sorts
    end;
    height.
:- objects
    leftend,rightend :: end;
    low,high :: height.
:- variables
    E, E1, E2 :: end;
    H, H1, H2 :: height.
:- constants
    level(end) :: inertialFluent(height);
    onTable :: inertialFluent;
    lift(end) :: action.

Write the following constraints:
% The object is on the table if the level of the leftend is the same as the level of the rightend.
% The object is not on the table if the level of the leftend is not the same as the level of the rightend.
% Lifting an end causes the level of that end to change.
% Lifting an end is not permissible if the level of that end is already high.
% Lifting an end is not permissible if the object is on the table.
% It is not permissible to lift both ends at the same time.

Constraints (only use fluents and actions specified for the problem):

% The object is on the table if the level of the leftend is the same as the level of the rightend.
onTable if level(leftend)=H & level(rightend)=H.

% The object is not on the table if the level of the leftend is not the same as the level of the rightend.
~onTable if level(leftend)=H1 & level(rightend)=H2 & H1\=H2.

% Lifting an end causes the level of that end to change.
lift(E) causes level(E)=high if level(E)=low.
lift(E) causes level(E)=low if level(E)=high.

% Lifting an end is not permissible if the level of that end is already high.
nonexecutable lift(E) if level(E)=high.

% Lifting an end is not permissible if the object is on the table.
nonexecutable lift(E) if onTable.

% It is not permissible to lift both ends at the same time.
nonexecutable lift(E1) & lift(E2).","The programming language BC is an action language which has two kinds of constants, a fluent constant and an action constant. An atom is of the form f=v, where f is a fluent constant, and v is an element of its domain. There are some shorthand rules which are described below. The shorthand versions expand into another form via a translation.


Rules in this form are not changed.
Example: 
Original rule: loc(person)=L if inCar & loc(car)=L.
Translation: loc(person)=L if inCar & loc(car)=L.


Example:
Original rule: status(light) = on after switch(on).
Translation: status(light) = on after switch(on).

ACTIONS

Example:
Original rule: drive(C,L) causes loc(C) = L.
Translation: loc(C)=L after drive(C,L).

Example:
Original rule: loc(car) = home & drive(home) & loc(car) = bank.
Translation: loc(car)  = home after drive(home) & loc(car) = bank.

DEFAULTS

Example:
Original Rule: default onTable(B) if color(B)=red.
Translation: onTable(B) if color(B) if cons onTable(B).

Example:
Original rule: default ~onTable(B) if pickedUp(B).
Translation: ~onTable(B) after pickedUp(B) if cons ~onTable(B).

IMPOSSIBLE

Example:
Original rule: impossible hasbrother(C) & ~hasSibling(C).
Translation: false if hasbrother(C) & ~hasSibling(C).

NONEXECUTABLE

Example:
Original rule: nonexecutable lift(object) if weight(object)=heavy.
Translation: false after lift(object) & weight(object)=heavy.

Translate the following programs:

Program 1

Domain:
:- sorts
    loc >> block;
    block_w_none >> block;
    machine;
    gripper.

:- objects
    table :: loc;
    b1, b2, b3, b4 :: block;
    m1, m2 :: machine;
    g1, g2, g3 :: gripper.

:- constants
    loc(block) :: inertialFluent(loc);
    gripped :: inertialFluent(block+none);
    in_tower(block) :: sdFluent;
    move(block, loc) :: action.

:-variables
    B, B1, B2 :: block;
    L, L1 :: loc.

Original rules:
% 1. Two blocks cannot be at the same location.
impossible loc(B1) = B & loc(B2) = B & B1\=B2.

% 2.1 A block is in a tower if it's location is on the table.
in_tower(B) if loc(B) = table.

% 2.2 A block is in a tower if it's location is on something that is in a tower.
in_tower(B) if loc(B) = B1 & in_tower(B1).

% 3. Blocks don't float in the air.
impossible ~in_tower(B).

% 4. Moving a block causes it's location to move to loc.
move(B,L) causes loc(B)=L.

% 5. The move action is impermissible if something is on the location to be moved to.
nonexecutable move(B,L) if loc(B1) = B.

% 6. By default, a block is not in the tower.
default ~in_tower(B).

% 7. The move action causes nothing to be gripped.
move(B,L) causes gripped(none).

Translation:


% 1. Two blocks cannot be at the same location.
false if loc(B1) = B & loc(B2) = B and B1\=B2.

% 2.1 A block is in a tower if it's location is on the table.
in_tower(B) if loc(B) = table.

% 2.2 A block is in a tower if it's location is on something that is in a tower.
in_tower(B) if loc(B) = B1 & in_tower(B1).

% 3. Blocks don't float in the air.
false if ~in_tower(B).

% 4. Moving a block causes it's location to move to loc.
loc(B)=L after move(B,L).

% 5. The move action is impermissible if something is on the location to be moved to.
false after move(B,L) & loc(B1) = B.

% 6. By default, a block is not in the tower.
~in_tower(B) if cons ~in_tower(B).

% 7. The move action causes nothing to be gripped.
gripped(none) if move(B,L).

Program 2

Domain:
:- sorts
    end;
    height.
:- objects
    leftend,rightend :: end;
    low,high :: height.
:- variables
    E, E1, E2 :: end;
    H, H1, H2 :: height.
:- constants
    level(end) :: inertialFluent(height);
    onTable :: inertialFluent;
    lift(end) :: action.

Original rules:
% The object is on the table if the level of the leftend is the same as the level of the rightend.
onTable if level(leftend)=H & level(rightend)=H.

% The object is not on the table if the level of the leftend is not the same as the level of the rightend.
~onTable if level(leftend)=H1 & level(rightend)=H2 & H1\=H2.

% Lifting an end causes the level of that end to change.
lift(E) causes level(E)=high if level(E)=low.
lift(E) causes level(E)=low if level(E)=high.

% Lifting an end is not permissible if the level of that end is already high.
nonexecutable lift(E) if level(E)=high.

% Lifting an end is not permissible if the object is on the table.
nonexecutable lift(E) if onTable.

% It is not permissible to lift both ends at the same time.
nonexecutable lift(E1) & lift(E2).

Translation:

% The object is on the table if the level of the leftend is the same as the level of the rightend.
onTable if level(leftend)=H & level(rightend)=H.

% The object is not on the table if the level of the leftend is not the same as the level of the rightend.
~onTable if level(leftend)=H1 & level(rightend)=H2 & H1\=H2.

% Lifting an end causes the level of that end to change.
level(E)=high after lift(E) if level(E)=low.
level(E)=low after lift(E) if level(E)=high.

% Lifting an end is not permissible if the level of that end is already high.
false after lift(E) & level(E)=high.

% Lifting an end is not permissible if the object is on the table.
false after lift(E) & onTable.

% It is not permissible to lift both ends at the same time.
false if lift(E1) & lift(E2).","The programming language BC is an action language which has two kinds of constants, a fluent constant and an action constant. An atom is of the form f=v, where f is a fluent constant, and v is an element of its domain. These rules eventuall get translated into another form.

Atoms are generally in the form ""f=v"", but can be written short form ""f"" if it represents a boolean variable, and hence ""v"" is true and false.

Here, we will translate rules and their atoms. If the atom is of the form ""f=v"", then it will be copied as ""holds(f(v),i)"" according to the translation, where v is an element in f's domain. If it is of the form of ""f"", then it will be copied as ""holds(f(v),I)"", where v is either true or false. I is a timestamp.

For example, the atom ""loc(car)=L"" may be translated to ""holds(loc(car, L),I)"", and the atom ""door(open)"" may be translated into ""holds(door(open, true),I)"" or ""holds(door(open,false),I)"" since it is boolean. 

Static laws:

Example:
Original rule: loc(person)=L if inCar & loc(car)=L if cons on(car).
Translation: holds(loc(person,L),I) :- holds(incar(true),I), holds(loc(car,L),I), not not holds(on(car, true),I), timestep(I).

Example:
Original rule: false if hasbrother(C) & ~hasSibling(C).
Translation::- holds(hasbrother(C,true),I), holds(hasSibling(C,false),I), timestep(I).

Dynamic laws:

Example:
Original rule: status(light) = on after switch(on) if cons power(on) & connected.
Translation: holds(status(light,on),I+1) :- holds(switch(on,true),I), not not holds(power(on,true),I+1), not not holds(connected(true),I+1), timestep(I).

Example:
Original rule: false after lift(O) & weight(O)=heavy.
Translation: :- occurs(lift(object),I), holds(weight(O,heavy),I), timestep(I).

Translate the following programs:

Program 1:

BC Domain:
:- sorts
    loc >> block;
    block_w_none >> block;
    machine;
    gripper.

:- objects
    table :: loc;
    b1, b2, b3, b4 :: block;
    m1, m2 :: machine;
    g1, g2, g3 :: gripper.

:- constants
    loc(block) :: inertialFluent(loc);
    gripped :: inertialFluent(block+none);
    in_tower(block) :: sdFluent;
    move(block, loc) :: action.

ASP Domain:

% supersorts
s_loc(B) :- s_block(B).

% sorts
s_boolean(true;false).  

s_loc(table).
s_block(b1;b2;b3;b4).  
s_machine(m1;m2).
s_gripper(g1;g2).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loc(B,V),0)} :- s_block(B), s_loc(V).
{holds(gripper(V),0)} :- s_block_w_none(V).
{holds(in_tower(B,V),0)} :- s_block(B), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(move(B,L),T_step)} :- s_block(B), s_loc(L), timestep(T_step).

% Inertia

{holds(loc(B,V),T_step+1)} :-holds(loc(B,V),T_step), timestep(T_step).
{holds(gripped(V),T_step+1)} :-holds(gripped(V),T_step), timestep(T_step).
{holds(in_tower(B,V),T_step+1)} :-holds(in_tower(B,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint

:- not {holds(loc(B,V),T_step): s_loc(V)}=1, s_block(B), timestep(T_step).
:- not {holds(gripped(V),T_step): s_block_w_none(V)}=1, timestep(T_step).
:- not {holds(in_tower(B,V),T_step): s_boolean(V)}=1, s_block(B), timestep(T_step).


Rules:
% 1. Two blocks cannot be at the same location.
false if loc(B1) = B & loc(B2) = B and B1\=B2.

% 2.1 A block is in a tower if it's location is on the table.
in_tower(B) if loc(B) = table.

% 2.2 A block is in a tower if it's location is on something that is in a tower.
in_tower(B) if loc(B) = B1 & in_tower(B1).

% 3. Blocks don't float in the air.
false if ~in_tower(B).

% 4. Moving a block causes it's location to move to loc.
loc(B)=L after move(B,L).

% 5. The move action is impermissible if something is on the location to be moved to.
false after move(B,L) & loc(B1) = B.

% 6. By default, a block is not in the tower.
~in_tower(B) if cons ~in_tower(B).

% 7. The move action causes nothing to be gripped.
gripped=none if move(B,L).

Translation:
% 1. Two blocks cannot be at the same location.
:- holds(loc(B1,B),T_step), holds(loc(B2,B),T_step), B1!=B2, s_block(B), s_block(B1), s_block(B2), timestep(T_step).

% 2.1 A block is in a tower if it's location is on the table.
holds(in_tower(B,true),T_step) :- holds(loc(B,table),T_step), s_block(B), timestep(T_step).

% 2.2 A block is in a tower if it's location is on something that is in a tower.
holds(in_tower(B,true),T_step) :- holds(loc(B,B1),T_step), holds(in_tower(B1,true),T_step), s_block(B), s_block(B1), timestep(T_step).

% 3. Blocks don't float in the air.
:- holds(in_tower(B,true),T_step), s_block(B), timestep(T_step).

% 4. Moving a block causes it's location to move to loc.
holds(loc(B,L),T_step+1) :- occurs(move(B,L),T_step), s_block(B), s_loc(L), timestep(T_step).

% 5. The move action is impermissible if something is on the location to be moved to.
:- occurs(move(B,L),T_step), holds(loc(B1,B),T_step), s_block(B), s_block(B1), s_loc(L), timestep(T_step).

% 6. By default, a block is not in the tower.
holds(in_tower(B,false),T_step) :- not not holds(in_tower(B,false),T_step), s_block(B), timestep(T_step).

% 7. The move action causes nothing to be gripped.
holds(gripped(none),T_step+1) :- occurs(move(B,L),T_step), s_block(B), s_loc(L).

Program 2:

BC Domain:
:- sorts
    end;
    height.
:- objects
    leftend,rightend :: end;
    low,high :: height.
:- variables
    E, E1, E2 :: end;
    H, H1, H2 :: height.
:- constants
    level(end) :: inertialFluent(height);
    onTable :: inertialFluent;
    lift(end) :: action.

ASP Domain:
% supersorts
% No supersorts in this domain

% sorts
s_boolean(true;false).
s_end(leftend;rightend).
s_height(low;high).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(level(E,V),0)} :- s_end(E), s_height(V).
{holds(onTable(V),0)} :- s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(lift(E),T_step)} :- s_end(E), timestep(T_step).

% Inertia
{holds(level(E,V),T_step+1)} :-holds(level(E,V),T_step), timestep(T_step).
{holds(onTable(V),T_step+1)} :-holds(onTable(V),T_step), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(level(E,V),T_step): s_height(V)}=1, s_end(E), timestep(T_step).
:- not {holds(onTable(V),T_step): s_boolean(V)}=1, timestep(T_step).

Rules:
% The object is on the table if the level of the leftend is the same as the level of the rightend.
onTable if level(leftend)=H & level(rightend)=H.

% The object is not on the table if the level of the leftend is not the same as the level of the rightend.
~onTable if level(leftend)=H1 & level(rightend)=H2 & H1\=H2.

% Lifting an end causes the level of that end to change.
level(E)=high after lift(E) if level(E)=low.
level(E)=low after lift(E) if level(E)=high.

% Lifting an end is not permissible if the level of that end is already high.
false after lift(E) & level(E)=high.

% Lifting an end is not permissible if the object is on the table.
false after lift(E) & onTable.

% It is not permissible to lift both ends at the same time.
false if lift(E1) & lift(E2).

Translation:

% The object is on the table if the level of the leftend is the same as the level of the rightend.
holds(onTable(true),T_step) :- holds(level(leftend,H),T_step), holds(level(rightend,H),T_step), s_height(H), timestep(T_step).

% The object is not on the table if the level of the leftend is not the same as the level of the rightend.
holds(onTable(false),T_step) :- holds(level(leftend,H1),T_step), holds(level(rightend,H2),T_step), H1!=H2, s_height(H1), s_height(H2), timestep(T_step).

% Lifting an end causes the level of that end to change.
holds(level(E,high),T_step+1) :- occurs(lift(E),T_step), holds(level(E,low),T_step), s_end(E), timestep(T_step).
holds(level(E,low),T_step+1) :- occurs(lift(E),T_step), holds(level(E,high),T_step), s_end(E), timestep(T_step).

% Lifting an end is not permissible if the level of that end is already high.
:- occurs(lift(E),T_step), holds(level(E,high),T_step), s_end(E), timestep(T_step).

% Lifting an end is not permissible if the object is on the table.
:- occurs(lift(E),T_step), holds(onTable(true),T_step), s_end(E), timestep(T_step).

% It is not permissible to lift both ends at the same time.
:- occurs(lift(E1),T_step), occurs(lift(E2),T_step), E1!=E2, s_end(E1), s_end(E2), timestep(T_step).","Given the domain in ASP, convert the natural language queries into ASP form.

Program 1:

ASP Domain:
% supersorts
s_loc(B) :- s_block(B).

% sorts
s_boolean(true;false).  

s_loc(table).
s_block(b1;b2;b3;b4).  
s_machine(m1;m2).
s_gripper(g1;g2).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loc(B,V),0)} :- s_block(B), s_loc(V).
{holds(gripper(V),0)} :- s_block_w_none(V).
{holds(in_tower(B,V),0)} :- s_block(B), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(move(B,L),T_step)} :- s_block(B), s_loc(L), timestep(T_step).

% Inertia

{holds(loc(B,V),T_step+1)} :-holds(loc(B,V),T_step), timestep(T_step).
{holds(gripped(V),T_step+1)} :-holds(gripped(V),T_step), timestep(T_step).
{holds(in_tower(B,V),T_step+1)} :-holds(in_tower(B,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint

:- not {holds(loc(B,V),T_step): s_loc(V)}=1, s_block(B), timestep(T_step).
:- not {holds(gripped(V),T_step): s_block_w_none(V)}=1, timestep(T_step).
:- not {holds(in_tower(B,V),T_step): s_boolean(V)}=1, s_block(B), timestep(T_step).

Queries:
% Block b1 is on block b2 at time 0.

% Block b3 is moved onto block b4 at time 3.

% At time step 6, block b4 is on b3, b3 is on b2, and b2 is on b1.

ASP form:
% initially, block b1 is on block b2 at time 0.
holds(loc(b1,b2),0).

% block b3 is moved onto block b4 at time 3.
:- not occurs(move(b3),b4),3).

% At time step 6, block b4 is on b3, b3 is on b2, and b2 is on b1.
:- not holds(loc(b4,b3),0).
:- not holds(loc(b3,b2),0).
:- not holds(loc(b2,b1),0).

Program 2:
ASP Domain:
% supersorts
% No supersorts in this domain

% sorts
s_boolean(true;false).
s_end(leftend;rightend).
s_height(low;high).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(level(E,V),0)} :- s_end(E), s_height(V).
{holds(onTable(V),0)} :- s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(lift(E),T_step)} :- s_end(E), timestep(T_step).

% Inertia
{holds(level(E,V),T_step+1)} :-holds(level(E,V),T_step), timestep(T_step).
{holds(onTable(V),T_step+1)} :-holds(onTable(V),T_step), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(level(E,V),T_step): s_height(V)}=1, s_end(E), timestep(T_step).
:- not {holds(onTable(V),T_step): s_boolean(V)}=1, timestep(T_step).

Queries:
% The object is on the table initially at time 0.
% The object is not on the table at time 1.

ASP form:

% The object is on the table initially at time 0.
holds(onTable(true),0).

% The object is not on the table at time 1.
:- holds(onTable(true),1).","


% The object is on the table if the level of the leftend is the same as the level of the rightend.
% The object is not on the table if the level of the leftend is not the same as the level of the rightend.
% Lifting an end causes the level of that end to change.
% Lifting an end is not permissible if the level of that end is already high.
% Lifting an end is not permissible if the object is on the table.
% It is not permissible to lift both ends at the same time.


:- sorts
    end;
    height.
:- objects
    leftend,rightend :: end;
    low,high :: height.
:- variables
    E, E1, E2 :: end;
    H, H1, H2 :: height.
:- constants
    level(end) :: inertialFluent(height);
    onTable :: inertialFluent;
    lift(end) :: action.


% supersorts
% No supersorts in this domain

% sorts
s_boolean(true;false).
s_end(leftend;rightend).
s_height(low;high).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(level(E,V),0)} :- s_end(E), s_height(V).
{holds(onTable(V),0)} :- s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(lift(E),T_step)} :- s_end(E), timestep(T_step).

% Inertia
{holds(level(E,V),T_step+1)} :-holds(level(E,V),T_step), timestep(T_step).
{holds(onTable(V),T_step+1)} :-holds(onTable(V),T_step), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(level(E,V),T_step): s_height(V)}=1, s_end(E), timestep(T_step).
:- not {holds(onTable(V),T_step): s_boolean(V)}=1, timestep(T_step).


% The object is on the table if the level of the leftend is the same as the level of the rightend.
onTable if level(leftend)=H & level(rightend)=H.

% The object is not on the table if the level of the leftend is not the same as the level of the rightend.
~onTable if level(leftend)=H1 & level(rightend)=H2 & H1\=H2.

% Lifting an end causes the level of that end to change.
lift(E) causes level(E)=high if level(E)=low.
lift(E) causes level(E)=low if level(E)=high.

% Lifting an end is not permissible if the level of that end is already high.
nonexecutable lift(E) if level(E)=high.

% Lifting an end is not permissible if the object is on the table.
nonexecutable lift(E) if onTable.

% It is not permissible to lift both ends at the same time.
nonexecutable lift(E1) & lift(E2).


% The object is on the table if the level of the leftend is the same as the level of the rightend.
onTable if level(leftend)=H & level(rightend)=H.

% The object is not on the table if the level of the leftend is not the same as the level of the rightend.
~onTable if level(leftend)=H1 & level(rightend)=H2 & H1\=H2.

% Lifting an end causes the level of that end to change.
level(E)=high after lift(E) if level(E)=low.
level(E)=low after lift(E) if level(E)=high.

% Lifting an end is not permissible if the level of that end is already high.
false after lift(E) & level(E)=high.

% Lifting an end is not permissible if the object is on the table.
false after lift(E) & onTable.

% It is not permissible to lift both ends at the same time.
false if lift(E1) & lift(E2).


% The object is on the table if the level of the leftend is the same as the level of the rightend.
holds(onTable(true),T_step) :- holds(level(leftend,H),T_step), holds(level(rightend,H),T_step), s_height(H), timestep(T_step).

% The object is not on the table if the level of the leftend is not the same as the level of the rightend.
holds(onTable(false),T_step) :- holds(level(leftend,H1),T_step), holds(level(rightend,H2),T_step), H1!=H2, s_height(H1), s_height(H2), timestep(T_step).

% Lifting an end causes the level of that end to change.
holds(level(E,high),T_step+1) :- occurs(lift(E),T_step), holds(level(E,low),T_step), s_end(E), timestep(T_step).
holds(level(E,low),T_step+1) :- occurs(lift(E),T_step), holds(level(E,high),T_step), s_end(E), timestep(T_step).

% Lifting an end is not permissible if the level of that end is already high.
:- occurs(lift(E),T_step), holds(level(E,high),T_step), s_end(E), timestep(T_step).

% Lifting an end is not permissible if the object is on the table.
:- occurs(lift(E),T_step), holds(onTable(true),T_step), s_end(E), timestep(T_step).

% It is not permissible to lift both ends at the same time.
:- occurs(lift(E1),T_step), occurs(lift(E2),T_step), E1!=E2, s_end(E1), s_end(E2), timestep(T_step).


% The object is on the table initially at time 0.
holds(onTable(true),0).

% The object is not on the table at time 1.
:- holds(onTable(true),1).",":- sorts
    end;
    height.
:- objects
    leftend,rightend :: end;
    low,high :: height.
:- variables
    E, E1, E2 :: end;
    H, H1, H2 :: height.
:- constants
    level(end) :: inertialFluent(height);
    onTable :: inertialFluent;
    lift(end) :: action.


% The object is on the table if the level of the leftend is the same as the level of the rightend.
onTable if level(leftend)=H & level(rightend)=H.

% The object is not on the table if the level of the leftend is not the same as the level of the rightend.
~onTable if level(leftend)=H1 & level(rightend)=H2 & H1\=H2.

% Lifting an end causes the level of that end to change.
lift(E) causes level(E)=high if level(E)=low.
lift(E) causes level(E)=low if level(E)=high.

% Lifting an end is not permissible if the level of that end is already high.
nonexecutable lift(E) if level(E)=high.

% Lifting an end is not permissible if the object is on the table.
nonexecutable lift(E) if onTable.

% It is not permissible to lift both ends at the same time.
nonexecutable lift(E1) & lift(E2).","% supersorts
% No supersorts in this domain

% sorts
s_boolean(true;false).
s_end(leftend;rightend).
s_height(low;high).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(level(E,V),0)} :- s_end(E), s_height(V).
{holds(onTable(V),0)} :- s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(lift(E),T_step)} :- s_end(E), timestep(T_step).

% Inertia
{holds(level(E,V),T_step+1)} :-holds(level(E,V),T_step), timestep(T_step).
{holds(onTable(V),T_step+1)} :-holds(onTable(V),T_step), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(level(E,V),T_step): s_height(V)}=1, s_end(E), timestep(T_step).
:- not {holds(onTable(V),T_step): s_boolean(V)}=1, timestep(T_step).


% The object is on the table if the level of the leftend is the same as the level of the rightend.
holds(onTable(true),T_step) :- holds(level(leftend,H),T_step), holds(level(rightend,H),T_step), s_height(H), timestep(T_step).

% The object is not on the table if the level of the leftend is not the same as the level of the rightend.
holds(onTable(false),T_step) :- holds(level(leftend,H1),T_step), holds(level(rightend,H2),T_step), H1!=H2, s_height(H1), s_height(H2), timestep(T_step).

% Lifting an end causes the level of that end to change.
holds(level(E,high),T_step+1) :- occurs(lift(E),T_step), holds(level(E,low),T_step), s_end(E), timestep(T_step).
holds(level(E,low),T_step+1) :- occurs(lift(E),T_step), holds(level(E,high),T_step), s_end(E), timestep(T_step).

% Lifting an end is not permissible if the level of that end is already high.
:- occurs(lift(E),T_step), holds(level(E,high),T_step), s_end(E), timestep(T_step).

% Lifting an end is not permissible if the object is on the table.
:- occurs(lift(E),T_step), holds(onTable(true),T_step), s_end(E), timestep(T_step).

% It is not permissible to lift both ends at the same time.
:- occurs(lift(E1),T_step), occurs(lift(E2),T_step), E1!=E2, s_end(E1), s_end(E2), timestep(T_step).


% The object is on the table initially at time 0.
holds(onTable(true),0).

% The object is not on the table at time 1.
:- holds(onTable(true),1)."
shooting prompts,"To perform the task of shooting a turkey, one needs to load, aim, and finally shoot the gun while aiming at the turkey. Provide the relevant commonsense knowledge.
Some things to consider are the requirements for successfully shooting a turkey, and the effects of shooting it.
----------------------------------------------------------------------



% The gun is unloaded at time step 3.

% The turkey is alive at time step 1.

","Given a description of a problem, write commonsense knowledge about the domain that we would expect. These represent logical constraints in the problem.

For example, a task about moving objects would involve some knowledge about what is required to move, what the effect of moving an object does, such as the location of the object changing or its previous location now being empty. 

These restrictions and effects are dependent on the context of the problem. Here we list some example problems and extract commonsense knowledge.

Problem 1
Description:
A monkey wants to get a bunch of bananas hanging from the ceiling. He can reach the bananas by first pushing a box to the empty place under the bananas and then climbing on top of the box. The task is to come up with a plan for retrieving the bananas.
Some things to consider are the monkey, the bananas, the box, the location of objects, and the monkey's ability to move and push the box. Provide the relevant commonsense knowledge. Only use the terminology in the hint to write the commonsense knowledge.

Hint:
There are two main types of things: ""things"" and ""location"".

monkey, bananas, and box are things.
l1, l2, and l3 are locations.

Fluents:
A (thing)'s location is a simple fluent (location).
Having bananas is a simple fluent (boolean).
Being on the box are simple fluents (boolean).

Actions:
walk to a (location)
push box to a (location)
climb on
climb off
grasp bananas

Commonsense knowledge (do not provide any extra knowledge that is not included in the description):
% The location of the bananas is where the monkey is if the monkey has bananas.
% The location of the monkey is where the box is if the monkey is on the box.
% Walking to a location causes the monkey’s location to change.
% Walking is not permissible to a location if the monkey is already in that location
% Walking is not permissible if the monkey is on the box.
% Pushing the box to a location causes the location of the box to move.
% Pushing the box to a location causes the location f the monkey to move.
% Pushing the box is not permissible to a location if the monkey is at that location
% Pushing the box is not permissible if the monkey is on the box.
% Pushing the box is not permissible if the location of the monkey is not the same as the location of the box.
% Climbing on the box causes the monkey to be on the box.
% Climbing on the box is not permissible if the monkey is already on the box.
% Climbing on the box is not permissible if the location of the monkey is not the same as the box.
% Climbing off of the box causes the monkey to not be on the box.
% Climbing off of the box is not permissible if the monkey is not on the box.
% Grasping the bananas causes the monkey to have the bananas.
% Grasping the bananas is not permissible if the monkey already has the bananas.
% Grasping the bananas is not permissible if the monkey is not on the box.
% Grasping the bananas is not permissible if the location of the monkey is not the same as the location of the bananas.
% It is not permissible to both walk to a location and push the box to a location.
% It is not permissible to both walk to a location and climb on the box.
% It is not permissible to both push the box to a location and climb on the box.
% It is not permissible to both climb off of the box and grasp the bananas.

Problem 2:
Description:
To perform the task of shooting a turkey, one needs to load, aim, and finally shoot the gun while aiming at the turkey. Provide the relevant commonsense knowledge.
Some things to consider are the requirements for successfully shooting a turkey, and the effects of shooting it.

Hint:
There is one type of thing: ""turkey"".

t1 and t2 are turkeys.

Fluents
The gun being loaded is a inertial fluent (boolean).
The (turkey) being alive is an inertial fluent.
The target is an inertial fluent (turkey).


Loading the gun is an action.
Aiming at a (turkey) is an action.
Shooting is an action.

Actions:
load the gun
aim the gun at the turkey
shoot the gun
Commonsense knowledge (do not provide any extra knowledge that is not included in the description):

% Loading the gun causes the gun to be loaded.
% Loading the gun is not permissible if the gun is already loaded.
% Aiming at a turkey causes the target to be that turkey.
% Aiming at a turkey is not permissible if the gun is not loaded.
% Shooting causes the turkey to not be alive if the target is that turkey.
% Shooting is not permissible if the gun is not loaded.
% Shooting is not permissible if the gun is not aimed at a turkey.
% It is not permissible to both load the gun and aim at a turkey.
% It is not permissible to both load the gun and shoot.
% It is not permissible to both aim at a turkey and shoot.","Action language BC specifies the syntax of the domain in the form of sorts, objects, variables, and constants. 

A sort is a named set of elements which is used to specify the domain of each constant and variable. First the sort is declared
using a sort declaration statement and, later, is defined by adding objects to it in an object declaration statement.

Sort declaration:
:- sorts
    int;
    box.

This declares the domains: int, and box.

An object is a value in a sort which a constant can take. It is also used
in parameter lists to construct nested objects and sets of constants. 

Object declaration:
:- objects
    1..3 :: int;
    o(int, int) :: box.

This declares 1,2, and 3 as objects within int, and the objects:
o(1, 1), o(1, 2), o(1, 3),
o(2, 1), o(2, 2), o(2, 3),
o(3, 1), o(3, 2), and o(3, 3),
as values within box.

A variable is a placeholder symbol which will be replaced with each object in its domain during grounding.

Variable declaration:
:- variables
    I, I1, I2 :: int;
    B, B1, B2 :: box.
This declares the variables I, I1, and I2 over the objects within int, and variables B, B1, and B2 range over the objects within box.

Constant symbols are the basic components of multivalued formulas. Similar to object symbols, constants are defined within a constant declaration statement and have a base identifier, an optional list of parameter sort, and a sort which makes up the constant’s domain. In addition, they may have a constant declaration type, such as ""action"", ""simpleFluent"", and ""inertialFluent"". Inertial fluents are used for constants whose value persists through time unless affected otherwise.
Constant declaration:
:- constants
    p(int) :: inertialFluent;
    move(box) :: action.
This declares the inertial fluent p which takes an int argument, and the action move, which takes a box argument.

Given some knowledge about a domain, produce the sorts, objects, variables, and constants for the action language BC. 

Problem 1
Problem description:
A monkey wants to get a bunch of bananas hanging from the ceiling. He can reach the bananas by first pushing a box to the empty place under the bananas and then climbing on top of the box.

Hint:
There are three main types of things: ""monkey"", ""thing"" and ""location"".
""thing"" includes ""monkey"".

monkey, bananas, and box are things.
l1, l2, and l3 are locations.

Fluents:
A (thing)'s location is a simple fluent (location).
Having bananas is a simple fluent (boolean).
Being on the box are simple fluents (boolean).

Actions:
walk to a (location)
push box to a (location)
climb on
climb off
grasp bananas

Knowledge:
% The location of the bananas is where the monkey is if the monkey has bananas.
% The location of the monkey is where the box is if the monkey is on the box.
% Walking to a location causes the monkey’s location to change.
% Walking is not permissible to a location if the monkey is already in that location
% Walking is not permissible if the monkey is on the box.
% Pushing the box to a location causes the location of the box to move.
% Pushing the box to a location causes the location f the monkey to move.
% Pushing the box is not permissible to a location if the monkey is at that location
% Pushing the box is not permissible if the monkey is on the box.
% Pushing the box is not permissible if the location of the monkey is not the same as the location of the box.
% Climbing on the box causes the monkey to be on the box.
% Climbing on the box is not permissible if the monkey is already on the box.
% Climbing on the box is not permissible if the location of the monkey is not the same as the box.
% Climbing off of the box causes the monkey to not be on the box.
% Climbing off of the box is not permissible if the monkey is not on the box.
% Grasping the bananas causes the monkey to have the bananas.
% Grasping the bananas is not permissible if the monkey already has the bananas.
% Grasping the bananas is not permissible if the monkey is not on the box.
% Grasping the bananas is not permissible if the location of the monkey is not the same as the location of the bananas.
% It is not permissible to both walk to a location and push the box to a location.
% It is not permissible to both walk to a location and climb on the box.
% It is not permissible to both push the box to a location and climb on the box.
% It is not permissible to both climb off of the box and grasp the bananas.

BC domain syntax:
:- sorts
    thing >> monkey;
    location.
:- objects
    monkey,bananas,box :: thing;
    l1,l2,l3 :: location.
:- variables
    Loc, Loc1, Loc2 :: location;
    Bool, Bool1, Bool2 :: boolean.
:- constants
    loc(thing) :: simpleFluent(location);
    hasBananas,onBox :: simpleFluent;
    walk(location) :: action;
    pushBox(location) :: action;
    climbOn :: action;
    climbOff :: action;
    graspBananas :: action.


Problem 2
Problem description:
To perform the task of shooting a turkey, one needs to load, aim, and finally shoot the gun while aiming at the turkey. Provide the relevant commonsense knowledge.
Some things to consider are the requirements for successfully shooting a turkey, and the effects of shooting it.

Hint:
There is one type of thing: ""turkey"".

t1 and t2 are turkeys.

Fluents
The gun being loaded is a inertial fluent (boolean).
The (turkey) being alive is an inertial fluent.
The target is an inertial fluent (turkey).


Loading the gun is an action.
Aiming at a (turkey) is an action.
Shooting is an action.

Actions:
load the gun
aim the gun at the turkey
shoot the gun

Knowledge:
% Loading the gun causes the gun to be loaded.
% Loading the gun is not permissible if the gun is already loaded.
% Aiming at a turkey causes the target to be that turkey.
% Aiming at a turkey is not permissible if the gun is not loaded.
% Shooting causes the turkey to not be alive if the target is that turkey.
% Shooting is not permissible if the gun is not loaded.
% Shooting is not permissible if the gun is not aimed at a turkey.
% It is not permissible to both load the gun and aim at a turkey.
% It is not permissible to both load the gun and shoot.
% It is not permissible to both aim at a turkey and shoot.

BC domain syntax:

:- sorts
    turkey.
:- objects
    t1,t2 :: turkey.
:- variables
    T, T1, T2 :: turkey;
    Bool, Bool1, Bool2 :: boolean.
:- constants
    loaded :: inertialFluent;
    alive(turkey) :: inertialFluent;
    target :: inertialFluent(turkey);
    load :: action;
    aim(turkey) :: action;
    shoot :: action.","The programming language BC is an action language which has two kinds of constants, a fluent constant and an action constant. Answer Set Programming (ASP) is a logic programming paradigm. Given a domain specification in BC, generate ASP code which represents the supersorts (if applicable), sorts, choice rule for every fluent constant, choice rule for every action constant, inertial rules, and the uniqueness/existence constraint for each atom.
s_boolean(true;false) represents the boolean values true and false and is always used.
Write the constraints according to the given domains into BC:

Program 1:

Domain:
:- sorts
    loc >> block;
    block_w_none >> block;
    machine;
    gripper.

:- objects
    table :: loc;
    b1, b2, b3, b4 :: block;
    none :: block_w_none;
    m1, m2 :: machine;
    g1, g2, g3 :: gripper.

:- constants
    loc(block) :: inertialFluent(loc);
    gripped :: inertialFluent(block_w_none);
    in_tower(block) :: sdFluent;
    move(block, loc) :: action.

:-variables
    B, B1, B2 :: block;
    B_none :: block_w_none;
    L, L1 :: loc.


Generated constraints:

% supersorts
s_loc(B) :- s_block(B).
s_block_w_none :- s_block(B).

% sorts
s_boolean(true;false).
s_block_w_none(none).

s_loc(table).
s_block(b1;b2;b3;b4).
s_machine(m1;m2).
s_gripper(g1;g2).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loc(B,V),0)} :- s_block(B), s_loc(V).
{holds(gripped(V),0)} :- s_block_w_none(V).
{holds(in_tower(B,V),0)} :- s_block(B), s_boolean(V).


% choice rule {i:a} for every action constant a and every i < l
{occurs(move(B,L),T_step)} :- s_block(B), s_loc(L), timestep(T_step).

% Inertia

{holds(loc(B,V),T_step+1)} :-holds(loc(B,V),T_step), timestep(T_step).
{holds(gripped(V),T_step+1)} :-holds(gripped(V),T_step), timestep(T_step).
{holds(in_tower(B,V),T_step+1)} :-holds(in_tower(B,V),T_step), timestep(T_step).


% existence and uniqueness of value constraint

:- not {holds(loc(B,V),T_step): s_loc(V)}=1, s_block(B), timestep(T_step).
:- not {holds(gripped(V),T_step): s_block_w_none(V)}=1, timestep(T_step).
:- not {holds(in_tower(B,V),T_step): s_boolean(V)}=1, s_block(B), timestep(T_step).

Program 2:

Domain:
:- sorts
    turkey.
:- objects
    t1,t2 :: turkey.
:- variables
    T, T1, T2 :: turkey;
    Bool, Bool1, Bool2 :: boolean.
:- constants
    loaded :: inertialFluent;
    alive(turkey) :: inertialFluent;
    target :: inertialFluent(turkey);
    load :: action;
    aim(turkey) :: action;
    shoot :: action.

Generated constraints:

% supersorts
% No supersorts in this domain

% sorts
s_boolean(true;false).
s_turkey(t1;t2).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loaded,V,0)} :- s_boolean(V).
{holds(alive(T,V),0)} :- s_turkey(T), s_boolean(V).
{holds(target(T,V),0)} :- s_turkey(T), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(load,T_step)} :- timestep(T_step).
{occurs(aim(T),T_step)} :- s_turkey(T), timestep(T_step).
{occurs(shoot,T_step)} :- timestep(T_step).

% Inertia
{holds(loaded,V,T_step+1)} :-holds(loaded,V,T_step), timestep(T_step).
{holds(alive(T,V),T_step+1)} :-holds(alive(T,V),T_step), s_turkey(T), timestep(T_step).
{holds(target(T,V),T_step+1)} :-holds(target(T,V),T_step), s_turkey(T), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(loaded,V,T_step): s_boolean(V)}=1, timestep(T_step).
:- not {holds(alive(T,V),T_step): s_boolean(V)}=1, s_turkey(T), timestep(T_step).
:- not {holds(target(T,V),T_step): s_boolean(V)}=1, s_turkey(T), timestep(T_step).","A program in BC consists of causal rules of the following 2 forms where their readings are shown after ""%"".
There are two kinds of constants, a fluent constant and an action constant. An  atom is of the form f=v, where f is a fluent constant, and v is an element of its domain. A fluent which has no argument, such as ""hasGas"" is assumed to be boolean. 

An expression of the form:
A_0 if A_1 & A_2 & ... & A_n

where A_i are atoms, expresses the static law that A_0 is true if the conjunction of A_1 & ... & A_n is true.

Example:
% The location of a person is the same as the car if the person is in the car.
loc(person)=L if inCar & loc(car)=L.
Note that the head of the rule (loc(person)=L in the example), must be only a single atom. So the following rule is not valid:
loc(person)=loc(car) if inCar.

An expression of the form:
F causes G if H

where  F is an action, G is an atom and H is a conjunction of atoms, expresses that action F causes G to be true if H is true. 

It also stands for the fluent dynamic law:
caused G after F & H
which expresses that atom G is causes after action F and atom H are true.

Example:
open(D) causes opened(D) if available(D).

Here are some common ways to write rules.

An expression of the form:
impossible A_1 & A_2 & ... & A_n

where A_i are atoms, is used to express that the conjunction of A_i is impossible.

Example:
impossible hasbrother(C) & ~hasSibling(C).
(note that impossible must only have conjunction (&), and cannot contain ""if"")
The form ""impossible A_1 if ..."" is incorrect while ""impossible A_1 & ..."" is correct.

For example, the following is incorrect:
impossible hasbrother(C) if ~hasSibling(C).

An expression of the form:
nonexecutable a_1 & ... & a_n if A_1 & A_2 & ... & A_m.

where a_i are actions and A_i are atoms, is used to express that an action cannot be executed if the conjunction of A_i is true.

Examples:
% It is not permissible to drive a car if it has no gas.
nonexecutable driveCar if ~hasGas.
% It is not permissible to lift an object if it is heavy.
nonexecutable lift(object) if heavy(object).

Example:
default onTable(B) if block(B). 

Examples
default door(open) if door(unlocked) after push(door).

In general, if something cannot be true, then we use ""impossible"" when writing the rules, but if instead we want to assert something is not true, then we use the negation (~). For example, if it is impossible for an object to be on the table and under it, we might write ""impossible onTable(object) & underTable(object)."", but express that if it rains outside the ground is not wet as ""~groundWet if noRain"".
Additionally, ""impossible"" is reserved only for fluents, while ""nonexecutable"" is only reserved for actions.

Here is an example representation.
Problem 1:
:- sorts
    thing;
    location.
:- objects
    monkey,bananas,box :: thing;
    l1,l2,l3 :: location.
:- variables
    Loc, Loc1, Loc2 :: location;
    Bool, Bool1, Bool2 :: boolean.
:- constants
    loc(thing) :: simpleFluent(location);
    hasBananas,onBox :: simpleFluent;
    walk(location) :: action;
    pushBox(location) :: action;
    climbOn :: action;
    climbOff :: action;
    graspBananas :: action.

Represent the following constraints:
% The location of the bananas is where the monkey is if the monkey has bananas.
% The location of the monkey is where the box is if the monkey is on the box.
% The monkey cannot be in two places at once.
% Walking to a location causes the monkey’s location to change.
% Walking is not permissible to a location if the monkey is already in that location
% Walking is not permissible if the monkey is on the box.
% Pushing the box to a location causes the location of the box to move.
% Pushing the box to a location causes the location of the monkey to move.
% Pushing the box is not permissible to a location if the monkey is at that location
% Pushing the box is not permissible if the monkey is on the box.
% Pushing the box is not permissible if the location of the monkey is not the same as the location of the box.
% Climbing on the box causes the monkey to be on the box.
% Climbing on the box is not permissible if the monkey is already on the box.
% Climbing on the box is not permissible if the location of the monkey is not the same as the box.
% Climbing off of the box causes the monkey to not be on the box.
% Climbing off of the box is not permissible if the monkey is not on the box.
% Grasping the bananas causes the monkey to have the bananas.
% Grasping the bananas is not permissible if the monkey already has the bananas.
% Grasping the bananas is not permissible if the monkey is not on the box.
% Grasping the bananas is not permissible if the location of the monkey is not the same as the location of the bananas.
% It is not permissible to both walk to a location and push the box to a location.
% It is not permissible to both walk to a location and climb on the box.
% It is not permissible to both push the box to a location and climb on the box.
% It is not permissible to both climb off of the box and grasp the bananas.

Constraints (only use fluents and actions specified for the problem):
% The location of the bananas is where the monkey is if the monkey has bananas.
loc(bananas)=L if hasBananas & loc(monkey)=L.

% The location of the monkey is where the box is if the monkey is on the box.
loc(monkey)=L if onBox & loc(box)=L.

% The monkey cannot be in two places at once.
impossible loc(monkey) = L1 & loc(monkey)=L2 & L1\=L2.

% Walking to a location causes the monkey’s location to change.
walk(L) causes loc(monkey)=L.

% Walking is not permissible to a location if the monkey is already in that location
nonexecutable walk(L) if loc(monkey)=L.

% Walking is not permissible if the monkey is on the box.
nonexecutable walk(L) if onBox.

% Pushing the box to a location causes the location of the box to move.
pushBox(L) causes loc(box)=L.

% Pushing the box to a location causes the location of the monkey to move.
pushBox(L) causes loc(monkey)=L.

% Pushing the box is not permissible to a location if the monkey is at that location
nonexecutable pushBox(L) if loc(monkey)=L.

% Pushing the box is not permissible if the monkey is on the box.
nonexecutable pushBox(L) if onBox.

% Pushing the box is not permissible if the location of the monkey is not the same as the location of the box.
nonexecutable pushBox(L) if loc(monkey)\=loc(box).

% Climbing on the box causes the monkey to be on the box.
climbOn causes onBox.

% Climbing on the box is not permissible if the monkey is already on the box.
nonexecutable climbOn if onBox.

% Climbing on the box is not permissible if the location of the monkey is not the same as the box.
nonexecutable climbOn if loc(monkey)\=loc(box).

% Climbing off of the box causes the monkey to not be on the box.
climbOff causes ~onBox.

% Climbing off of the box is not permissible if the monkey is not on the box.
nonexecutable climbOff if ~onBox.

% Grasping the bananas causes the monkey to have the bananas.
graspBananas causes hasBananas.

% Grasping the bananas is not permissible if the monkey already has the bananas.
nonexecutable graspBananas if hasBananas.

% Grasping the bananas is not permissible if the monkey is not on the box.
nonexecutable graspBananas if ~onBox.

% Grasping the bananas is not permissible if the location of the monkey is not the same as the location of the bananas.
nonexecutable graspBananas if loc(monkey)\=loc(bananas).

% It is not permissible to both walk to a location and push the box to a location.
nonexecutable walk(L) & pushBox(L).

% It is not permissible to both walk to a location and climb on the box.
nonexecutable walk(L) & climbOn.

% It is not permissible to both push the box to a location and climb on the box.
nonexecutable pushBox(L) & climbOn.

% It is not permissible to both climb off of the box and grasp the bananas.
nonexecutable climbOff & graspBananas.

Problem 2:
Given the following domain:
:- sorts
    turkey.
:- objects
    t1,t2 :: turkey.
:- variables
    T, T1, T2 :: turkey;
    Bool, Bool1, Bool2 :: boolean.
:- constants
    loaded :: inertialFluent;
    alive(turkey) :: inertialFluent;
    target :: inertialFluent(turkey);
    load :: action;
    aim(turkey) :: action;
    shoot :: action.

Write the following constraints:
% Loading the gun causes the gun to be loaded.
% Loading the gun is not permissible if the gun is already loaded.
% Aiming at a turkey causes the target to be that turkey.
% Aiming at a turkey is not permissible if the gun is not loaded.
% Shooting causes the turkey to not be alive if the target is that turkey.
% Shooting is not permissible if the gun is not loaded.
% Shooting is not permissible if the gun is not aimed at a turkey.
% It is not permissible to both load the gun and aim at a turkey.
% It is not permissible to both load the gun and shoot.
% It is not permissible to both aim at a turkey and shoot.

Constraints (only use fluents and actions specified for the problem):

% Loading the gun causes the gun to be loaded.
load causes loaded.

% Loading the gun is not permissible if the gun is already loaded.
nonexecutable load if loaded.

% Aiming at a turkey causes the target to be that turkey.
aim(T) causes target=T.

% Aiming at a turkey is not permissible if the gun is not loaded.
nonexecutable aim(T) if ~loaded.

% Shooting causes the turkey to not be alive if the target is that turkey.
shoot causes ~alive(T) if target=T.

% Shooting is not permissible if the gun is not loaded.
nonexecutable shoot if ~loaded.

% Shooting is not permissible if the gun is not aimed at a turkey.
nonexecutable shoot if target\=T.

% It is not permissible to both load the gun and aim at a turkey.
nonexecutable load & aim(T).

% It is not permissible to both load the gun and shoot.
nonexecutable load & shoot.

% It is not permissible to both aim at a turkey and shoot.
nonexecutable aim(T) & shoot.","The programming language BC is an action language which has two kinds of constants, a fluent constant and an action constant. An atom is of the form f=v, where f is a fluent constant, and v is an element of its domain. There are some shorthand rules which are described below. The shorthand versions expand into another form via a translation.


Rules in this form are not changed.
Example: 
Original rule: loc(person)=L if inCar & loc(car)=L.
Translation: loc(person)=L if inCar & loc(car)=L.


Example:
Original rule: status(light) = on after switch(on).
Translation: status(light) = on after switch(on).

ACTIONS

Example:
Original rule: drive(C,L) causes loc(C) = L.
Translation: loc(C)=L after drive(C,L).

Example:
Original rule: loc(car) = home & drive(home) & loc(car) = bank.
Translation: loc(car)  = home after drive(home) & loc(car) = bank.

DEFAULTS

Example:
Original Rule: default onTable(B) if color(B)=red.
Translation: onTable(B) if color(B) if cons onTable(B).

Example:
Original rule: default ~onTable(B) if pickedUp(B).
Translation: ~onTable(B) after pickedUp(B) if cons ~onTable(B).

IMPOSSIBLE

Example:
Original rule: impossible hasbrother(C) & ~hasSibling(C).
Translation: false if hasbrother(C) & ~hasSibling(C).

NONEXECUTABLE

Example:
Original rule: nonexecutable lift(object) if weight(object)=heavy.
Translation: false after lift(object) & weight(object)=heavy.

Translate the following programs:

Program 1

Domain:
:- sorts
    loc >> block;
    block_w_none >> block;
    machine;
    gripper.

:- objects
    table :: loc;
    b1, b2, b3, b4 :: block;
    m1, m2 :: machine;
    g1, g2, g3 :: gripper.

:- constants
    loc(block) :: inertialFluent(loc);
    gripped :: inertialFluent(block+none);
    in_tower(block) :: sdFluent;
    move(block, loc) :: action.

:-variables
    B, B1, B2 :: block;
    L, L1 :: loc.

Original rules:
% 1. Two blocks cannot be at the same location.
impossible loc(B1) = B & loc(B2) = B & B1\=B2.

% 2.1 A block is in a tower if it's location is on the table.
in_tower(B) if loc(B) = table.

% 2.2 A block is in a tower if it's location is on something that is in a tower.
in_tower(B) if loc(B) = B1 & in_tower(B1).

% 3. Blocks don't float in the air.
impossible ~in_tower(B).

% 4. Moving a block causes it's location to move to loc.
move(B,L) causes loc(B)=L.

% 5. The move action is impermissible if something is on the location to be moved to.
nonexecutable move(B,L) if loc(B1) = B.

% 6. By default, a block is not in the tower.
default ~in_tower(B).

% 7. The move action causes nothing to be gripped.
move(B,L) causes gripped(none).

Translation:


% 1. Two blocks cannot be at the same location.
false if loc(B1) = B & loc(B2) = B and B1\=B2.

% 2.1 A block is in a tower if it's location is on the table.
in_tower(B) if loc(B) = table.

% 2.2 A block is in a tower if it's location is on something that is in a tower.
in_tower(B) if loc(B) = B1 & in_tower(B1).

% 3. Blocks don't float in the air.
false if ~in_tower(B).

% 4. Moving a block causes it's location to move to loc.
loc(B)=L after move(B,L).

% 5. The move action is impermissible if something is on the location to be moved to.
false after move(B,L) & loc(B1) = B.

% 6. By default, a block is not in the tower.
~in_tower(B) if cons ~in_tower(B).

% 7. The move action causes nothing to be gripped.
gripped(none) if move(B,L).

Program 2

Domain:
:- sorts
    turkey.
:- objects
    t1,t2 :: turkey.
:- variables
    T, T1, T2 :: turkey;
    Bool, Bool1, Bool2 :: boolean.
:- constants
    loaded :: inertialFluent;
    alive(turkey) :: inertialFluent;
    target :: inertialFluent(turkey);
    load :: action;
    aim(turkey) :: action;
    shoot :: action.

Original rules:
% Loading the gun causes the gun to be loaded.
load causes loaded.

% Loading the gun is not permissible if the gun is already loaded.
nonexecutable load if loaded.

% Aiming at a turkey causes the target to be that turkey.
aim(T) causes target=T.

% Aiming at a turkey is not permissible if the gun is not loaded.
nonexecutable aim(T) if ~loaded.

% Shooting causes the turkey to not be alive if the target is that turkey.
shoot causes ~alive(T) if target=T.

% Shooting is not permissible if the gun is not loaded.
nonexecutable shoot if ~loaded.

% Shooting is not permissible if the gun is not aimed at a turkey.
nonexecutable shoot if target\=T.

% It is not permissible to both load the gun and aim at a turkey.
nonexecutable load & aim(T).

% It is not permissible to both load the gun and shoot.
nonexecutable load & shoot.

% It is not permissible to both aim at a turkey and shoot.
nonexecutable aim(T) & shoot.

Translation:

% Loading the gun causes the gun to be loaded.
loaded after load.

% Loading the gun is not permissible if the gun is already loaded.
false after load & loaded.

% Aiming at a turkey causes the target to be that turkey.
target=T after aim(T).

% Aiming at a turkey is not permissible if the gun is not loaded.
false after aim(T) & ~loaded.

% Shooting causes the turkey to not be alive if the target is that turkey.
~alive(T) after shoot & target=T.

% Shooting is not permissible if the gun is not loaded.
false after shoot & ~loaded.

% Shooting is not permissible if the gun is not aimed at a turkey.
false after shoot & target\=T.

% It is not permissible to both load the gun and aim at a turkey.
false after load & aim(T).

% It is not permissible to both load the gun and shoot.
false after load & shoot.

% It is not permissible to both aim at a turkey and shoot.
false after aim(T) & shoot.","The programming language BC is an action language which has two kinds of constants, a fluent constant and an action constant. An atom is of the form f=v, where f is a fluent constant, and v is an element of its domain. These rules eventuall get translated into another form.

Atoms are generally in the form ""f=v"", but can be written short form ""f"" if it represents a boolean variable, and hence ""v"" is true and false.

Here, we will translate rules and their atoms. If the atom is of the form ""f=v"", then it will be copied as ""holds(f(v),i)"" according to the translation, where v is an element in f's domain. If it is of the form of ""f"", then it will be copied as ""holds(f(v),I)"", where v is either true or false. I is a timestamp.

For example, the atom ""loc(car)=L"" may be translated to ""holds(loc(car, L),I)"", and the atom ""door(open)"" may be translated into ""holds(door(open, true),I)"" or ""holds(door(open,false),I)"" since it is boolean. 

Static laws:

Example:
Original rule: loc(person)=L if inCar & loc(car)=L if cons on(car).
Translation: holds(loc(person,L),I) :- holds(incar(true),I), holds(loc(car,L),I), not not holds(on(car, true),I), timestep(I).

Example:
Original rule: false if hasbrother(C) & ~hasSibling(C).
Translation::- holds(hasbrother(C,true),I), holds(hasSibling(C,false),I), timestep(I).

Dynamic laws:

Example:
Original rule: status(light) = on after switch(on) if cons power(on) & connected.
Translation: holds(status(light,on),I+1) :- holds(switch(on,true),I), not not holds(power(on,true),I+1), not not holds(connected(true),I+1), timestep(I).

Example:
Original rule: false after lift(O) & weight(O)=heavy.
Translation: :- occurs(lift(object),I), holds(weight(O,heavy),I), timestep(I).

Translate the following programs:

Program 1:

BC Domain:
:- sorts
    loc >> block;
    block_w_none >> block;
    machine;
    gripper.

:- objects
    table :: loc;
    b1, b2, b3, b4 :: block;
    m1, m2 :: machine;
    g1, g2, g3 :: gripper.

:- constants
    loc(block) :: inertialFluent(loc);
    gripped :: inertialFluent(block+none);
    in_tower(block) :: sdFluent;
    move(block, loc) :: action.

ASP Domain:

% supersorts
s_loc(B) :- s_block(B).

% sorts
s_boolean(true;false).  

s_loc(table).
s_block(b1;b2;b3;b4).  
s_machine(m1;m2).
s_gripper(g1;g2).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loc(B,V),0)} :- s_block(B), s_loc(V).
{holds(gripper(V),0)} :- s_block_w_none(V).
{holds(in_tower(B,V),0)} :- s_block(B), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(move(B,L),T_step)} :- s_block(B), s_loc(L), timestep(T_step).

% Inertia

{holds(loc(B,V),T_step+1)} :-holds(loc(B,V),T_step), timestep(T_step).
{holds(gripped(V),T_step+1)} :-holds(gripped(V),T_step), timestep(T_step).
{holds(in_tower(B,V),T_step+1)} :-holds(in_tower(B,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint

:- not {holds(loc(B,V),T_step): s_loc(V)}=1, s_block(B), timestep(T_step).
:- not {holds(gripped(V),T_step): s_block_w_none(V)}=1, timestep(T_step).
:- not {holds(in_tower(B,V),T_step): s_boolean(V)}=1, s_block(B), timestep(T_step).


Rules:
% 1. Two blocks cannot be at the same location.
false if loc(B1) = B & loc(B2) = B and B1\=B2.

% 2.1 A block is in a tower if it's location is on the table.
in_tower(B) if loc(B) = table.

% 2.2 A block is in a tower if it's location is on something that is in a tower.
in_tower(B) if loc(B) = B1 & in_tower(B1).

% 3. Blocks don't float in the air.
false if ~in_tower(B).

% 4. Moving a block causes it's location to move to loc.
loc(B)=L after move(B,L).

% 5. The move action is impermissible if something is on the location to be moved to.
false after move(B,L) & loc(B1) = B.

% 6. By default, a block is not in the tower.
~in_tower(B) if cons ~in_tower(B).

% 7. The move action causes nothing to be gripped.
gripped=none if move(B,L).

Translation:
% 1. Two blocks cannot be at the same location.
:- holds(loc(B1,B),T_step), holds(loc(B2,B),T_step), B1!=B2, s_block(B), s_block(B1), s_block(B2), timestep(T_step).

% 2.1 A block is in a tower if it's location is on the table.
holds(in_tower(B,true),T_step) :- holds(loc(B,table),T_step), s_block(B), timestep(T_step).

% 2.2 A block is in a tower if it's location is on something that is in a tower.
holds(in_tower(B,true),T_step) :- holds(loc(B,B1),T_step), holds(in_tower(B1,true),T_step), s_block(B), s_block(B1), timestep(T_step).

% 3. Blocks don't float in the air.
:- holds(in_tower(B,true),T_step), s_block(B), timestep(T_step).

% 4. Moving a block causes it's location to move to loc.
holds(loc(B,L),T_step+1) :- occurs(move(B,L),T_step), s_block(B), s_loc(L), timestep(T_step).

% 5. The move action is impermissible if something is on the location to be moved to.
:- occurs(move(B,L),T_step), holds(loc(B1,B),T_step), s_block(B), s_block(B1), s_loc(L), timestep(T_step).

% 6. By default, a block is not in the tower.
holds(in_tower(B,false),T_step) :- not not holds(in_tower(B,false),T_step), s_block(B), timestep(T_step).

% 7. The move action causes nothing to be gripped.
holds(gripped(none),T_step+1) :- occurs(move(B,L),T_step), s_block(B), s_loc(L).

Program 2:

BC Domain:
:- sorts
    turkey.
:- objects
    t1,t2 :: turkey.
:- variables
    T, T1, T2 :: turkey;
    Bool, Bool1, Bool2 :: boolean.
:- constants
    loaded :: inertialFluent;
    alive(turkey) :: inertialFluent;
    target :: inertialFluent(turkey);
    load :: action;
    aim(turkey) :: action;
    shoot :: action.

ASP Domain:
% supersorts
% No supersorts in this domain

% sorts
s_boolean(true;false).
s_turkey(t1;t2).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loaded,V,0)} :- s_boolean(V).
{holds(alive(T,V),0)} :- s_turkey(T), s_boolean(V).
{holds(target(T,V),0)} :- s_turkey(T), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(load,T_step)} :- timestep(T_step).
{occurs(aim(T),T_step)} :- s_turkey(T), timestep(T_step).
{occurs(shoot,T_step)} :- timestep(T_step).

% Inertia
{holds(loaded,V,T_step+1)} :-holds(loaded,V,T_step), timestep(T_step).
{holds(alive(T,V),T_step+1)} :-holds(alive(T,V),T_step), s_turkey(T), timestep(T_step).
{holds(target(T,V),T_step+1)} :-holds(target(T,V),T_step), s_turkey(T), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(loaded,V,T_step): s_boolean(V)}=1, timestep(T_step).
:- not {holds(alive(T,V),T_step): s_boolean(V)}=1, s_turkey(T), timestep(T_step).
:- not {holds(target(T,V),T_step): s_boolean(V)}=1, s_turkey(T), timestep(T_step).

Rules:
% Loading the gun causes the gun to be loaded.
loaded after load.

% Loading the gun is not permissible if the gun is already loaded.
false after load & loaded.

% Aiming at a turkey causes the target to be that turkey.
target=T after aim(T).

% Aiming at a turkey is not permissible if the gun is not loaded.
false after aim(T) & ~loaded.

% Shooting causes the turkey to not be alive if the target is that turkey.
~alive(T) after shoot & target=T.

% Shooting is not permissible if the gun is not loaded.
false after shoot & ~loaded.

% Shooting is not permissible if the gun is not aimed at a turkey.
false after shoot & target\=T.

% It is not permissible to both load the gun and aim at a turkey.
false after load & aim(T).

% It is not permissible to both load the gun and shoot.
false after load & shoot.

% It is not permissible to both aim at a turkey and shoot.
false after aim(T) & shoot.

Translation:

% Loading the gun causes the gun to be loaded.
holds(loaded,true,T_step+1) :- occurs(load,T_step), timestep(T_step).

% Loading the gun is not permissible if the gun is already loaded.
:- occurs(load,T_step), holds(loaded,true,T_step), timestep(T_step).

% Aiming at a turkey causes the target to be that turkey.
holds(target(T,true),T_step+1) :- occurs(aim(T),T_step), s_turkey(T), timestep(T_step).

% Aiming at a turkey is not permissible if the gun is not loaded.
:- occurs(aim(T),T_step), holds(loaded,false,T_step), s_turkey(T), timestep(T_step).

% Shooting causes the turkey to not be alive if the target is that turkey.
holds(alive(T,false),T_step+1) :- occurs(shoot,T_step), holds(target(T,true),T_step), s_turkey(T), timestep(T_step).

% Shooting is not permissible if the gun is not loaded.
:- occurs(shoot,T_step), holds(loaded,false,T_step), timestep(T_step).

% Shooting is not permissible if the gun is not aimed at a turkey.
:- occurs(shoot,T_step), holds(target(T,false),T_step), s_turkey(T), timestep(T_step).

% It is not permissible to both load the gun and aim at a turkey.
:- occurs(load,T_step), occurs(aim(T),T_step), s_turkey(T), timestep(T_step).

% It is not permissible to both load the gun and shoot.
:- occurs(load,T_step), occurs(shoot,T_step), timestep(T_step).

% It is not permissible to both aim at a turkey and shoot.
:- occurs(aim(T),T_step), occurs(shoot,T_step), s_turkey(T), timestep(T_step).","Given the domain in ASP, convert the natural language queries into ASP form.

Program 1:

ASP Domain:
% supersorts
s_loc(B) :- s_block(B).

% sorts
s_boolean(true;false).  

s_loc(table).
s_block(b1;b2;b3;b4).  
s_machine(m1;m2).
s_gripper(g1;g2).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loc(B,V),0)} :- s_block(B), s_loc(V).
{holds(gripper(V),0)} :- s_block_w_none(V).
{holds(in_tower(B,V),0)} :- s_block(B), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(move(B,L),T_step)} :- s_block(B), s_loc(L), timestep(T_step).

% Inertia

{holds(loc(B,V),T_step+1)} :-holds(loc(B,V),T_step), timestep(T_step).
{holds(gripped(V),T_step+1)} :-holds(gripped(V),T_step), timestep(T_step).
{holds(in_tower(B,V),T_step+1)} :-holds(in_tower(B,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint

:- not {holds(loc(B,V),T_step): s_loc(V)}=1, s_block(B), timestep(T_step).
:- not {holds(gripped(V),T_step): s_block_w_none(V)}=1, timestep(T_step).
:- not {holds(in_tower(B,V),T_step): s_boolean(V)}=1, s_block(B), timestep(T_step).

Queries:
% Block b1 is on block b2 at time 0.

% Block b3 is moved onto block b4 at time 3.

% At time step 6, block b4 is on b3, b3 is on b2, and b2 is on b1.

ASP form:
% initially, block b1 is on block b2 at time 0.
holds(loc(b1,b2),0).

% block b3 is moved onto block b4 at time 3.
:- not occurs(move(b3),b4),3).

% At time step 6, block b4 is on b3, b3 is on b2, and b2 is on b1.
:- not holds(loc(b4,b3),0).
:- not holds(loc(b3,b2),0).
:- not holds(loc(b2,b1),0).

Program 2:
ASP Domain:
% supersorts
% No supersorts in this domain

% sorts
s_boolean(true;false).
s_turkey(t1;t2).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loaded,V,0)} :- s_boolean(V).
{holds(alive(T,V),0)} :- s_turkey(T), s_boolean(V).
{holds(target(T,V),0)} :- s_turkey(T), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(load,T_step)} :- timestep(T_step).
{occurs(aim(T),T_step)} :- s_turkey(T), timestep(T_step).
{occurs(shoot,T_step)} :- timestep(T_step).

% Inertia
{holds(loaded,V,T_step+1)} :-holds(loaded,V,T_step), timestep(T_step).
{holds(alive(T,V),T_step+1)} :-holds(alive(T,V),T_step), s_turkey(T), timestep(T_step).
{holds(target(T,V),T_step+1)} :-holds(target(T,V),T_step), s_turkey(T), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(loaded,V,T_step): s_boolean(V)}=1, timestep(T_step).
:- not {holds(alive(T,V),T_step): s_boolean(V)}=1, s_turkey(T), timestep(T_step).
:- not {holds(target(T,V),T_step): s_boolean(V)}=1, s_turkey(T), timestep(T_step).

Queries:
% The gun is unloaded at time step 3.

% The turkey is alive at time step 1.

ASP form:

% The gun is unloaded at time step 3.
:- not holds(loaded,false,3).

% The turkey is alive at time step 1.
:- not holds(alive(t1,true),1).","


% Loading the gun causes the gun to be loaded.
% Loading the gun is not permissible if the gun is already loaded.
% Aiming at a turkey causes the target to be that turkey.
% Aiming at a turkey is not permissible if the gun is not loaded.
% Shooting causes the turkey to not be alive if the target is that turkey.
% Shooting is not permissible if the gun is not loaded.
% Shooting is not permissible if the gun is not aimed at a turkey.
% It is not permissible to both load the gun and aim at a turkey.
% It is not permissible to both load the gun and shoot.
% It is not permissible to both aim at a turkey and shoot.


:- sorts
    turkey.
:- objects
    t1,t2 :: turkey.
:- variables
    T, T1, T2 :: turkey;
    Bool, Bool1, Bool2 :: boolean.
:- constants
    loaded :: inertialFluent;
    alive(turkey) :: inertialFluent;
    target :: inertialFluent(turkey);
    load :: action;
    aim(turkey) :: action;
    shoot :: action.


% supersorts
% No supersorts in this domain

% sorts
s_boolean(true;false).
s_turkey(t1;t2).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loaded,V,0)} :- s_boolean(V).
{holds(alive(T,V),0)} :- s_turkey(T), s_boolean(V).
{holds(target(T,V),0)} :- s_turkey(T), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(load,T_step)} :- timestep(T_step).
{occurs(aim(T),T_step)} :- s_turkey(T), timestep(T_step).
{occurs(shoot,T_step)} :- timestep(T_step).

% Inertia
{holds(loaded,V,T_step+1)} :-holds(loaded,V,T_step), timestep(T_step).
{holds(alive(T,V),T_step+1)} :-holds(alive(T,V),T_step), s_turkey(T), timestep(T_step).
{holds(target(T,V),T_step+1)} :-holds(target(T,V),T_step), s_turkey(T), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(loaded,V,T_step): s_boolean(V)}=1, timestep(T_step).
:- not {holds(alive(T,V),T_step): s_boolean(V)}=1, s_turkey(T), timestep(T_step).
:- not {holds(target(T,V),T_step): s_boolean(V)}=1, s_turkey(T), timestep(T_step).


% Loading the gun causes the gun to be loaded.
load causes loaded.

% Loading the gun is not permissible if the gun is already loaded.
nonexecutable load if loaded.

% Aiming at a turkey causes the target to be that turkey.
aim(T) causes target=T.

% Aiming at a turkey is not permissible if the gun is not loaded.
nonexecutable aim(T) if ~loaded.

% Shooting causes the turkey to not be alive if the target is that turkey.
shoot causes ~alive(T) if target=T.

% Shooting is not permissible if the gun is not loaded.
nonexecutable shoot if ~loaded.

% Shooting is not permissible if the gun is not aimed at a turkey.
nonexecutable shoot if target\=T.

% It is not permissible to both load the gun and aim at a turkey.
nonexecutable load & aim(T).

% It is not permissible to both load the gun and shoot.
nonexecutable load & shoot.

% It is not permissible to both aim at a turkey and shoot.
nonexecutable aim(T) & shoot.


% Loading the gun causes the gun to be loaded.
loaded after load.

% Loading the gun is not permissible if the gun is already loaded.
false after load & loaded.

% Aiming at a turkey causes the target to be that turkey.
target=T after aim(T).

% Aiming at a turkey is not permissible if the gun is not loaded.
false after aim(T) & ~loaded.

% Shooting causes the turkey to not be alive if the target is that turkey.
~alive(T) after shoot & target=T.

% Shooting is not permissible if the gun is not loaded.
false after shoot & ~loaded.

% Shooting is not permissible if the gun is not aimed at a turkey.
false after shoot & target\=T.

% It is not permissible to both load the gun and aim at a turkey.
false after load & aim(T).

% It is not permissible to both load the gun and shoot.
false after load & shoot.

% It is not permissible to both aim at a turkey and shoot.
false after aim(T) & shoot.


% Loading the gun causes the gun to be loaded.
holds(loaded,true,T_step+1) :- occurs(load,T_step), timestep(T_step).

% Loading the gun is not permissible if the gun is already loaded.
:- occurs(load,T_step), holds(loaded,true,T_step), timestep(T_step).

% Aiming at a turkey causes the target to be that turkey.
holds(target(T,true),T_step+1) :- occurs(aim(T),T_step), s_turkey(T), timestep(T_step).

% Aiming at a turkey is not permissible if the gun is not loaded.
:- occurs(aim(T),T_step), holds(loaded,false,T_step), s_turkey(T), timestep(T_step).

% Shooting causes the turkey to not be alive if the target is that turkey.
holds(alive(T,false),T_step+1) :- occurs(shoot,T_step), holds(target(T,true),T_step), s_turkey(T), timestep(T_step).

% Shooting is not permissible if the gun is not loaded.
:- occurs(shoot,T_step), holds(loaded,false,T_step), timestep(T_step).

% Shooting is not permissible if the gun is not aimed at a turkey.
:- occurs(shoot,T_step), holds(target(T,false),T_step), s_turkey(T), timestep(T_step).

% It is not permissible to both load the gun and aim at a turkey.
:- occurs(load,T_step), occurs(aim(T),T_step), s_turkey(T), timestep(T_step).

% It is not permissible to both load the gun and shoot.
:- occurs(load,T_step), occurs(shoot,T_step), timestep(T_step).

% It is not permissible to both aim at a turkey and shoot.
:- occurs(aim(T),T_step), occurs(shoot,T_step), s_turkey(T), timestep(T_step).


% The gun is unloaded at time step 3.
:- not holds(loaded,false,3).

% The turkey is alive at time step 1.
:- not holds(alive(t1,true),1).",":- sorts
    turkey.
:- objects
    t1,t2 :: turkey.
:- variables
    T, T1, T2 :: turkey;
    Bool, Bool1, Bool2 :: boolean.
:- constants
    loaded :: inertialFluent;
    alive(turkey) :: inertialFluent;
    target :: inertialFluent(turkey);
    load :: action;
    aim(turkey) :: action;
    shoot :: action.


% Loading the gun causes the gun to be loaded.
load causes loaded.

% Loading the gun is not permissible if the gun is already loaded.
nonexecutable load if loaded.

% Aiming at a turkey causes the target to be that turkey.
aim(T) causes target=T.

% Aiming at a turkey is not permissible if the gun is not loaded.
nonexecutable aim(T) if ~loaded.

% Shooting causes the turkey to not be alive if the target is that turkey.
shoot causes ~alive(T) if target=T.

% Shooting is not permissible if the gun is not loaded.
nonexecutable shoot if ~loaded.

% Shooting is not permissible if the gun is not aimed at a turkey.
nonexecutable shoot if target\=T.

% It is not permissible to both load the gun and aim at a turkey.
nonexecutable load & aim(T).

% It is not permissible to both load the gun and shoot.
nonexecutable load & shoot.

% It is not permissible to both aim at a turkey and shoot.
nonexecutable aim(T) & shoot.","% supersorts
% No supersorts in this domain

% sorts
s_boolean(true;false).
s_turkey(t1;t2).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loaded,V,0)} :- s_boolean(V).
{holds(alive(T,V),0)} :- s_turkey(T), s_boolean(V).
{holds(target(T,V),0)} :- s_turkey(T), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(load,T_step)} :- timestep(T_step).
{occurs(aim(T),T_step)} :- s_turkey(T), timestep(T_step).
{occurs(shoot,T_step)} :- timestep(T_step).

% Inertia
{holds(loaded,V,T_step+1)} :-holds(loaded,V,T_step), timestep(T_step).
{holds(alive(T,V),T_step+1)} :-holds(alive(T,V),T_step), s_turkey(T), timestep(T_step).
{holds(target(T,V),T_step+1)} :-holds(target(T,V),T_step), s_turkey(T), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(loaded,V,T_step): s_boolean(V)}=1, timestep(T_step).
:- not {holds(alive(T,V),T_step): s_boolean(V)}=1, s_turkey(T), timestep(T_step).
:- not {holds(target(T,V),T_step): s_boolean(V)}=1, s_turkey(T), timestep(T_step).


% Loading the gun causes the gun to be loaded.
holds(loaded,true,T_step+1) :- occurs(load,T_step), timestep(T_step).

% Loading the gun is not permissible if the gun is already loaded.
:- occurs(load,T_step), holds(loaded,true,T_step), timestep(T_step).

% Aiming at a turkey causes the target to be that turkey.
holds(target(T,true),T_step+1) :- occurs(aim(T),T_step), s_turkey(T), timestep(T_step).

% Aiming at a turkey is not permissible if the gun is not loaded.
:- occurs(aim(T),T_step), holds(loaded,false,T_step), s_turkey(T), timestep(T_step).

% Shooting causes the turkey to not be alive if the target is that turkey.
holds(alive(T,false),T_step+1) :- occurs(shoot,T_step), holds(target(T,true),T_step), s_turkey(T), timestep(T_step).

% Shooting is not permissible if the gun is not loaded.
:- occurs(shoot,T_step), holds(loaded,false,T_step), timestep(T_step).

% Shooting is not permissible if the gun is not aimed at a turkey.
:- occurs(shoot,T_step), holds(target(T,false),T_step), s_turkey(T), timestep(T_step).

% It is not permissible to both load the gun and aim at a turkey.
:- occurs(load,T_step), occurs(aim(T),T_step), s_turkey(T), timestep(T_step).

% It is not permissible to both load the gun and shoot.
:- occurs(load,T_step), occurs(shoot,T_step), timestep(T_step).

% It is not permissible to both aim at a turkey and shoot.
:- occurs(aim(T),T_step), occurs(shoot,T_step), s_turkey(T), timestep(T_step).


% The gun is unloaded at time step 3.
:- not holds(loaded,false,3).

% The turkey is alive at time step 1.
:- not holds(alive(t1,true),1)."
hanoi prompts,"To successfully stack disks in a tower, one needs to move disks off of other disks or pegs to achieve the desired ordered stack. Provide the relevant commonsense knowledge.
----------------------------------------------------------------------



 % Initially, disk d1 is in disk d2 at time 0.
% Initially, disk d2 is on disk d3 at time 0.
% Initially, disk d3 is on peg a at time 0.

% Disk d3 is on disk d2 at time 6.
% Disk d2 is on disk d1 at time 6.
% Disk d1 is on peg c at time 6.

","Given a description of a problem, write commonsense knowledge about the domain that we would expect. These represent logical constraints in the problem.

For example, a task about moving objects would involve some knowledge about what is required to move, what the effect of moving an object does, such as the location of the object changing or its previous location now being empty. 

These restrictions and effects are dependent on the context of the problem. Here we list some example problems and extract commonsense knowledge.

Problem 1
Description:
A monkey wants to get a bunch of bananas hanging from the ceiling. He can reach the bananas by first pushing a box to the empty place under the bananas and then climbing on top of the box. The task is to come up with a plan for retrieving the bananas.
Some things to consider are the monkey, the bananas, the box, the location of objects, and the monkey's ability to move and push the box. Provide the relevant commonsense knowledge. Only use the terminology in the hint to write the commonsense knowledge.

Hint:
There are two main types of things: ""things"" and ""location"".

monkey, bananas, and box are things.
l1, l2, and l3 are locations.

Fluents:
A (thing)'s location is a simple fluent (location).
Having bananas is a simple fluent (boolean).
Being on the box are simple fluents (boolean).

Actions:
walk to a (location)
push box to a (location)
climb on
climb off
grasp bananas

Commonsense knowledge (do not provide any extra knowledge that is not included in the description):
% The location of the bananas is where the monkey is if the monkey has bananas.
% The location of the monkey is where the box is if the monkey is on the box.
% Walking to a location causes the monkey’s location to change.
% Walking is not permissible to a location if the monkey is already in that location
% Walking is not permissible if the monkey is on the box.
% Pushing the box to a location causes the location of the box to move.
% Pushing the box to a location causes the location f the monkey to move.
% Pushing the box is not permissible to a location if the monkey is at that location
% Pushing the box is not permissible if the monkey is on the box.
% Pushing the box is not permissible if the location of the monkey is not the same as the location of the box.
% Climbing on the box causes the monkey to be on the box.
% Climbing on the box is not permissible if the monkey is already on the box.
% Climbing on the box is not permissible if the location of the monkey is not the same as the box.
% Climbing off of the box causes the monkey to not be on the box.
% Climbing off of the box is not permissible if the monkey is not on the box.
% Grasping the bananas causes the monkey to have the bananas.
% Grasping the bananas is not permissible if the monkey already has the bananas.
% Grasping the bananas is not permissible if the monkey is not on the box.
% Grasping the bananas is not permissible if the location of the monkey is not the same as the location of the bananas.
% It is not permissible to both walk to a location and push the box to a location.
% It is not permissible to both walk to a location and climb on the box.
% It is not permissible to both push the box to a location and climb on the box.
% It is not permissible to both climb off of the box and grasp the bananas.

Problem 2:
Description:
To successfully stack disks in a tower, one needs to move disks off of other disks or pegs to achieve the desired ordered stack. Provide the relevant commonsense knowledge.

Hint:
There are three types of things: ""loc"", ""disk"", and ""peg"".
a,b, and c are pegs.
d1, d2, and d2 are disks. 

Fluents:
The (disk)'s location is an inertial fluent (loc).
A (disk) being in a tower is an inertial fluent.

Actions:
Moving a (disk) to a (loc) is an action. 

Commonsense knowledge (do not provide any extra knowledge that is not included in the description):

% The location of a disk changes when it is moved.
% A disk cannot be moved if it is under another disk.
% A disk cannot be moved to a location if there is already a disk at that location.
% A disk can only be moved to a location if that location is a peg or the top of a tower.
% A disk becomes part of a tower when it is moved to the top of a tower.
% A disk is no longer part of a tower when it is moved from the top of a tower.
% A disk cannot be moved to a location if the disk is larger than the disk at the top of the tower at that location.
% A disk cannot be moved to a location if the disk is the same size as the disk at the top of the tower at that location.
% It is not permissible to move a disk to a location and move another disk to the same location at the same time.
% It is not permissible to move a disk from a location and move another disk from the same location at the same time.","Action language BC specifies the syntax of the domain in the form of sorts, objects, variables, and constants. 

A sort is a named set of elements which is used to specify the domain of each constant and variable. First the sort is declared
using a sort declaration statement and, later, is defined by adding objects to it in an object declaration statement.

Sort declaration:
:- sorts
    int;
    box.

This declares the domains: int, and box.

An object is a value in a sort which a constant can take. It is also used
in parameter lists to construct nested objects and sets of constants. 

Object declaration:
:- objects
    1..3 :: int;
    o(int, int) :: box.

This declares 1,2, and 3 as objects within int, and the objects:
o(1, 1), o(1, 2), o(1, 3),
o(2, 1), o(2, 2), o(2, 3),
o(3, 1), o(3, 2), and o(3, 3),
as values within box.

A variable is a placeholder symbol which will be replaced with each object in its domain during grounding.

Variable declaration:
:- variables
    I, I1, I2 :: int;
    B, B1, B2 :: box.
This declares the variables I, I1, and I2 over the objects within int, and variables B, B1, and B2 range over the objects within box.

Constant symbols are the basic components of multivalued formulas. Similar to object symbols, constants are defined within a constant declaration statement and have a base identifier, an optional list of parameter sort, and a sort which makes up the constant’s domain. In addition, they may have a constant declaration type, such as ""action"", ""simpleFluent"", and ""inertialFluent"". Inertial fluents are used for constants whose value persists through time unless affected otherwise.
Constant declaration:
:- constants
    p(int) :: inertialFluent;
    move(box) :: action.
This declares the inertial fluent p which takes an int argument, and the action move, which takes a box argument.

Given some knowledge about a domain, produce the sorts, objects, variables, and constants for the action language BC. 

Problem 1
Problem description:
A monkey wants to get a bunch of bananas hanging from the ceiling. He can reach the bananas by first pushing a box to the empty place under the bananas and then climbing on top of the box.

Hint:
There are three main types of things: ""monkey"", ""thing"" and ""location"".
""thing"" includes ""monkey"".

monkey, bananas, and box are things.
l1, l2, and l3 are locations.

Fluents:
A (thing)'s location is a simple fluent (location).
Having bananas is a simple fluent (boolean).
Being on the box are simple fluents (boolean).

Actions:
walk to a (location)
push box to a (location)
climb on
climb off
grasp bananas

Knowledge:
% The location of the bananas is where the monkey is if the monkey has bananas.
% The location of the monkey is where the box is if the monkey is on the box.
% Walking to a location causes the monkey’s location to change.
% Walking is not permissible to a location if the monkey is already in that location
% Walking is not permissible if the monkey is on the box.
% Pushing the box to a location causes the location of the box to move.
% Pushing the box to a location causes the location f the monkey to move.
% Pushing the box is not permissible to a location if the monkey is at that location
% Pushing the box is not permissible if the monkey is on the box.
% Pushing the box is not permissible if the location of the monkey is not the same as the location of the box.
% Climbing on the box causes the monkey to be on the box.
% Climbing on the box is not permissible if the monkey is already on the box.
% Climbing on the box is not permissible if the location of the monkey is not the same as the box.
% Climbing off of the box causes the monkey to not be on the box.
% Climbing off of the box is not permissible if the monkey is not on the box.
% Grasping the bananas causes the monkey to have the bananas.
% Grasping the bananas is not permissible if the monkey already has the bananas.
% Grasping the bananas is not permissible if the monkey is not on the box.
% Grasping the bananas is not permissible if the location of the monkey is not the same as the location of the bananas.
% It is not permissible to both walk to a location and push the box to a location.
% It is not permissible to both walk to a location and climb on the box.
% It is not permissible to both push the box to a location and climb on the box.
% It is not permissible to both climb off of the box and grasp the bananas.

BC domain syntax:
:- sorts
    thing >> monkey;
    location.
:- objects
    monkey,bananas,box :: thing;
    l1,l2,l3 :: location.
:- variables
    Loc, Loc1, Loc2 :: location;
    Bool, Bool1, Bool2 :: boolean.
:- constants
    loc(thing) :: simpleFluent(location);
    hasBananas,onBox :: simpleFluent;
    walk(location) :: action;
    pushBox(location) :: action;
    climbOn :: action;
    climbOff :: action;
    graspBananas :: action.


Problem 2
Problem description:
To successfully stack disks in a tower, one needs to move disks off of other disks or pegs to achieve the desired ordered stack. Provide the relevant commonsense knowledge.

Hint:
There are three types of things: ""loc"", ""disk"", and ""peg"".
a,b, and c are pegs.
d1, d2, and d2 are disks. 

Fluents:
The (disk)'s location is an inertial fluent (loc).
A (disk) being in a tower is an inertial fluent.

Actions:
Moving a (disk) to a (loc) is an action. 


Knowledge:
% The location of a disk changes when it is moved.
% A disk cannot be moved if it is under another disk.
% A disk cannot be moved to a location if there is already a disk at that location.
% A disk can only be moved to a location if that location is a peg or the top of a tower.
% A disk becomes part of a tower when it is moved to the top of a tower.
% A disk is no longer part of a tower when it is moved from the top of a tower.
% A disk cannot be moved to a location if the disk is larger than the disk at the top of the tower at that location.
% A disk cannot be moved to a location if the disk is the same size as the disk at the top of the tower at that location.
% It is not permissible to move a disk to a location and move another disk to the same location at the same time.
% It is not permissible to move a disk from a location and move another disk from the same location at the same time.

BC domain syntax:

:- sorts
    loc >> peg;
    disk.
:- objects
    a,b,c :: peg;
    d1,d2,d3 :: disk.
:- variables
    L, L1, L2 :: loc;
    D, D1, D2 :: disk.
:- constants
    loc(disk) :: inertialFluent(loc);
    inTower(disk) :: inertialFluent;
    move(disk, loc) :: action.","The programming language BC is an action language which has two kinds of constants, a fluent constant and an action constant. Answer Set Programming (ASP) is a logic programming paradigm. Given a domain specification in BC, generate ASP code which represents the supersorts (if applicable), sorts, choice rule for every fluent constant, choice rule for every action constant, inertial rules, and the uniqueness/existence constraint for each atom.
s_boolean(true;false) represents the boolean values true and false and is always used.
Write the constraints according to the given domains into BC:

Program 1:

Domain:
:- sorts
    loc >> block;
    block_w_none >> block;
    machine;
    gripper.

:- objects
    table :: loc;
    b1, b2, b3, b4 :: block;
    none :: block_w_none;
    m1, m2 :: machine;
    g1, g2, g3 :: gripper.

:- constants
    loc(block) :: inertialFluent(loc);
    gripped :: inertialFluent(block_w_none);
    in_tower(block) :: sdFluent;
    move(block, loc) :: action.

:-variables
    B, B1, B2 :: block;
    B_none :: block_w_none;
    L, L1 :: loc.


Generated constraints:

% supersorts
s_loc(B) :- s_block(B).
s_block_w_none :- s_block(B).

% sorts
s_boolean(true;false).
s_block_w_none(none).

s_loc(table).
s_block(b1;b2;b3;b4).
s_machine(m1;m2).
s_gripper(g1;g2).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loc(B,V),0)} :- s_block(B), s_loc(V).
{holds(gripped(V),0)} :- s_block_w_none(V).
{holds(in_tower(B,V),0)} :- s_block(B), s_boolean(V).


% choice rule {i:a} for every action constant a and every i < l
{occurs(move(B,L),T_step)} :- s_block(B), s_loc(L), timestep(T_step).

% Inertia

{holds(loc(B,V),T_step+1)} :-holds(loc(B,V),T_step), timestep(T_step).
{holds(gripped(V),T_step+1)} :-holds(gripped(V),T_step), timestep(T_step).
{holds(in_tower(B,V),T_step+1)} :-holds(in_tower(B,V),T_step), timestep(T_step).


% existence and uniqueness of value constraint

:- not {holds(loc(B,V),T_step): s_loc(V)}=1, s_block(B), timestep(T_step).
:- not {holds(gripped(V),T_step): s_block_w_none(V)}=1, timestep(T_step).
:- not {holds(in_tower(B,V),T_step): s_boolean(V)}=1, s_block(B), timestep(T_step).

Program 2:

Domain:
:- sorts
    loc >> peg;
    disk.
:- objects
    a,b,c :: peg;
    d1,d2,d3 :: disk.
:- variables
    L, L1, L2 :: loc;
    D, D1, D2 :: disk.
:- constants
    loc(disk) :: inertialFluent(loc);
    inTower(disk) :: inertialFluent;
    move(disk, loc) :: action.

Generated constraints:

% supersorts
s_loc(P) :- s_peg(P).

% sorts
s_boolean(true;false).
s_peg(a;b;c).
s_disk(d1;d2;d3).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loc(D,V),0)} :- s_disk(D), s_loc(V).
{holds(inTower(D,V),0)} :- s_disk(D), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(move(D,L),T_step)} :- s_disk(D), s_loc(L), timestep(T_step).

% Inertia
{holds(loc(D,V),T_step+1)} :-holds(loc(D,V),T_step), timestep(T_step).
{holds(inTower(D,V),T_step+1)} :-holds(inTower(D,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(loc(D,V),T_step): s_loc(V)}=1, s_disk(D), timestep(T_step).
:- not {holds(inTower(D,V),T_step): s_boolean(V)}=1, s_disk(D), timestep(T_step).","A program in BC consists of causal rules of the following 2 forms where their readings are shown after ""%"".
There are two kinds of constants, a fluent constant and an action constant. An  atom is of the form f=v, where f is a fluent constant, and v is an element of its domain. A fluent which has no argument, such as ""hasGas"" is assumed to be boolean. 

An expression of the form:
A_0 if A_1 & A_2 & ... & A_n

where A_i are atoms, expresses the static law that A_0 is true if the conjunction of A_1 & ... & A_n is true.

Example:
% The location of a person is the same as the car if the person is in the car.
loc(person)=L if inCar & loc(car)=L.
Note that the head of the rule (loc(person)=L in the example), must be only a single atom. So the following rule is not valid:
loc(person)=loc(car) if inCar.

An expression of the form:
F causes G if H

where  F is an action, G is an atom and H is a conjunction of atoms, expresses that action F causes G to be true if H is true. 

It also stands for the fluent dynamic law:
caused G after F & H
which expresses that atom G is causes after action F and atom H are true.

Example:
open(D) causes opened(D) if available(D).

Here are some common ways to write rules.

An expression of the form:
impossible A_1 & A_2 & ... & A_n

where A_i are atoms, is used to express that the conjunction of A_i is impossible.

Example:
impossible hasbrother(C) & ~hasSibling(C).
(note that impossible must only have conjunction (&), and cannot contain ""if"")
The form ""impossible A_1 if ..."" is incorrect while ""impossible A_1 & ..."" is correct.

For example, the following is incorrect:
impossible hasbrother(C) if ~hasSibling(C).

An expression of the form:
nonexecutable a_1 & ... & a_n if A_1 & A_2 & ... & A_m.

where a_i are actions and A_i are atoms, is used to express that an action cannot be executed if the conjunction of A_i is true.

Examples:
% It is not permissible to drive a car if it has no gas.
nonexecutable driveCar if ~hasGas.
% It is not permissible to lift an object if it is heavy.
nonexecutable lift(object) if heavy(object).

Example:
default onTable(B) if block(B). 

Examples
default door(open) if door(unlocked) after push(door).

In general, if something cannot be true, then we use ""impossible"" when writing the rules, but if instead we want to assert something is not true, then we use the negation (~). For example, if it is impossible for an object to be on the table and under it, we might write ""impossible onTable(object) & underTable(object)."", but express that if it rains outside the ground is not wet as ""~groundWet if noRain"".
Additionally, ""impossible"" is reserved only for fluents, while ""nonexecutable"" is only reserved for actions.

Here is an example representation.
Problem 1:
:- sorts
    thing;
    location.
:- objects
    monkey,bananas,box :: thing;
    l1,l2,l3 :: location.
:- variables
    Loc, Loc1, Loc2 :: location;
    Bool, Bool1, Bool2 :: boolean.
:- constants
    loc(thing) :: simpleFluent(location);
    hasBananas,onBox :: simpleFluent;
    walk(location) :: action;
    pushBox(location) :: action;
    climbOn :: action;
    climbOff :: action;
    graspBananas :: action.

Represent the following constraints:
% The location of the bananas is where the monkey is if the monkey has bananas.
% The location of the monkey is where the box is if the monkey is on the box.
% The monkey cannot be in two places at once.
% Walking to a location causes the monkey’s location to change.
% Walking is not permissible to a location if the monkey is already in that location
% Walking is not permissible if the monkey is on the box.
% Pushing the box to a location causes the location of the box to move.
% Pushing the box to a location causes the location of the monkey to move.
% Pushing the box is not permissible to a location if the monkey is at that location
% Pushing the box is not permissible if the monkey is on the box.
% Pushing the box is not permissible if the location of the monkey is not the same as the location of the box.
% Climbing on the box causes the monkey to be on the box.
% Climbing on the box is not permissible if the monkey is already on the box.
% Climbing on the box is not permissible if the location of the monkey is not the same as the box.
% Climbing off of the box causes the monkey to not be on the box.
% Climbing off of the box is not permissible if the monkey is not on the box.
% Grasping the bananas causes the monkey to have the bananas.
% Grasping the bananas is not permissible if the monkey already has the bananas.
% Grasping the bananas is not permissible if the monkey is not on the box.
% Grasping the bananas is not permissible if the location of the monkey is not the same as the location of the bananas.
% It is not permissible to both walk to a location and push the box to a location.
% It is not permissible to both walk to a location and climb on the box.
% It is not permissible to both push the box to a location and climb on the box.
% It is not permissible to both climb off of the box and grasp the bananas.

Constraints (only use fluents and actions specified for the problem):
% The location of the bananas is where the monkey is if the monkey has bananas.
loc(bananas)=L if hasBananas & loc(monkey)=L.

% The location of the monkey is where the box is if the monkey is on the box.
loc(monkey)=L if onBox & loc(box)=L.

% The monkey cannot be in two places at once.
impossible loc(monkey) = L1 & loc(monkey)=L2 & L1\=L2.

% Walking to a location causes the monkey’s location to change.
walk(L) causes loc(monkey)=L.

% Walking is not permissible to a location if the monkey is already in that location
nonexecutable walk(L) if loc(monkey)=L.

% Walking is not permissible if the monkey is on the box.
nonexecutable walk(L) if onBox.

% Pushing the box to a location causes the location of the box to move.
pushBox(L) causes loc(box)=L.

% Pushing the box to a location causes the location of the monkey to move.
pushBox(L) causes loc(monkey)=L.

% Pushing the box is not permissible to a location if the monkey is at that location
nonexecutable pushBox(L) if loc(monkey)=L.

% Pushing the box is not permissible if the monkey is on the box.
nonexecutable pushBox(L) if onBox.

% Pushing the box is not permissible if the location of the monkey is not the same as the location of the box.
nonexecutable pushBox(L) if loc(monkey)\=loc(box).

% Climbing on the box causes the monkey to be on the box.
climbOn causes onBox.

% Climbing on the box is not permissible if the monkey is already on the box.
nonexecutable climbOn if onBox.

% Climbing on the box is not permissible if the location of the monkey is not the same as the box.
nonexecutable climbOn if loc(monkey)\=loc(box).

% Climbing off of the box causes the monkey to not be on the box.
climbOff causes ~onBox.

% Climbing off of the box is not permissible if the monkey is not on the box.
nonexecutable climbOff if ~onBox.

% Grasping the bananas causes the monkey to have the bananas.
graspBananas causes hasBananas.

% Grasping the bananas is not permissible if the monkey already has the bananas.
nonexecutable graspBananas if hasBananas.

% Grasping the bananas is not permissible if the monkey is not on the box.
nonexecutable graspBananas if ~onBox.

% Grasping the bananas is not permissible if the location of the monkey is not the same as the location of the bananas.
nonexecutable graspBananas if loc(monkey)\=loc(bananas).

% It is not permissible to both walk to a location and push the box to a location.
nonexecutable walk(L) & pushBox(L).

% It is not permissible to both walk to a location and climb on the box.
nonexecutable walk(L) & climbOn.

% It is not permissible to both push the box to a location and climb on the box.
nonexecutable pushBox(L) & climbOn.

% It is not permissible to both climb off of the box and grasp the bananas.
nonexecutable climbOff & graspBananas.

Problem 2:
Given the following domain:
:- sorts
    loc >> peg;
    disk.
:- objects
    a,b,c :: peg;
    d1,d2,d3 :: disk.
:- variables
    L, L1, L2 :: loc;
    D, D1, D2 :: disk.
:- constants
    loc(disk) :: inertialFluent(loc);
    inTower(disk) :: inertialFluent;
    move(disk, loc) :: action.

Write the following constraints:
% The location of a disk changes when it is moved.
% A disk cannot be moved if it is under another disk.
% A disk cannot be moved to a location if there is already a disk at that location.
% A disk can only be moved to a location if that location is a peg or the top of a tower.
% A disk becomes part of a tower when it is moved to the top of a tower.
% A disk is no longer part of a tower when it is moved from the top of a tower.
% A disk cannot be moved to a location if the disk is larger than the disk at the top of the tower at that location.
% A disk cannot be moved to a location if the disk is the same size as the disk at the top of the tower at that location.
% It is not permissible to move a disk to a location and move another disk to the same location at the same time.
% It is not permissible to move a disk from a location and move another disk from the same location at the same time.

Constraints (only use fluents and actions specified for the problem):

% The location of a disk changes when it is moved.
move(D,L) causes loc(D)=L.

% A disk cannot be moved if it is under another disk.
nonexecutable move(D,L) if inTower(D).

% A disk cannot be moved to a location if there is already a disk at that location.
nonexecutable move(D,L) if loc(D1)=L & D1\=D.

% A disk can only be moved to a location if that location is a peg or the top of a tower.
nonexecutable move(D,L) if ~peg(L) & ~inTower(D1) & loc(D1)=L.

% A disk becomes part of a tower when it is moved to the top of a tower.
move(D,L) causes inTower(D) if inTower(D1) & loc(D1)=L.

% A disk is no longer part of a tower when it is moved from the top of a tower.
move(D,L) causes ~inTower(D) if inTower(D) & loc(D)\=L.

% A disk cannot be moved to a location if the disk is larger than the disk at the top of the tower at that location.
nonexecutable move(D,L) if inTower(D1) & loc(D1)=L & D>D1.

% A disk cannot be moved to a location if the disk is the same size as the disk at the top of the tower at that location.
nonexecutable move(D,L) if inTower(D1) & loc(D1)=L & D=D1.

% It is not permissible to move a disk to a location and move another disk to the same location at the same time.
nonexecutable move(D1,L) & move(D2,L) if D1\=D2.

% It is not permissible to move a disk from a location and move another disk from the same location at the same time.
nonexecutable move(D1,L1) & move(D2,L2) if loc(D1)=loc(D2) & L1\=L2.","The programming language BC is an action language which has two kinds of constants, a fluent constant and an action constant. An atom is of the form f=v, where f is a fluent constant, and v is an element of its domain. There are some shorthand rules which are described below. The shorthand versions expand into another form via a translation.


Rules in this form are not changed.
Example: 
Original rule: loc(person)=L if inCar & loc(car)=L.
Translation: loc(person)=L if inCar & loc(car)=L.


Example:
Original rule: status(light) = on after switch(on).
Translation: status(light) = on after switch(on).

ACTIONS

Example:
Original rule: drive(C,L) causes loc(C) = L.
Translation: loc(C)=L after drive(C,L).

Example:
Original rule: loc(car) = home & drive(home) & loc(car) = bank.
Translation: loc(car)  = home after drive(home) & loc(car) = bank.

DEFAULTS

Example:
Original Rule: default onTable(B) if color(B)=red.
Translation: onTable(B) if color(B) if cons onTable(B).

Example:
Original rule: default ~onTable(B) if pickedUp(B).
Translation: ~onTable(B) after pickedUp(B) if cons ~onTable(B).

IMPOSSIBLE

Example:
Original rule: impossible hasbrother(C) & ~hasSibling(C).
Translation: false if hasbrother(C) & ~hasSibling(C).

NONEXECUTABLE

Example:
Original rule: nonexecutable lift(object) if weight(object)=heavy.
Translation: false after lift(object) & weight(object)=heavy.

Translate the following programs:

Program 1

Domain:
:- sorts
    loc >> block;
    block_w_none >> block;
    machine;
    gripper.

:- objects
    table :: loc;
    b1, b2, b3, b4 :: block;
    m1, m2 :: machine;
    g1, g2, g3 :: gripper.

:- constants
    loc(block) :: inertialFluent(loc);
    gripped :: inertialFluent(block+none);
    in_tower(block) :: sdFluent;
    move(block, loc) :: action.

:-variables
    B, B1, B2 :: block;
    L, L1 :: loc.

Original rules:
% 1. Two blocks cannot be at the same location.
impossible loc(B1) = B & loc(B2) = B & B1\=B2.

% 2.1 A block is in a tower if it's location is on the table.
in_tower(B) if loc(B) = table.

% 2.2 A block is in a tower if it's location is on something that is in a tower.
in_tower(B) if loc(B) = B1 & in_tower(B1).

% 3. Blocks don't float in the air.
impossible ~in_tower(B).

% 4. Moving a block causes it's location to move to loc.
move(B,L) causes loc(B)=L.

% 5. The move action is impermissible if something is on the location to be moved to.
nonexecutable move(B,L) if loc(B1) = B.

% 6. By default, a block is not in the tower.
default ~in_tower(B).

% 7. The move action causes nothing to be gripped.
move(B,L) causes gripped(none).

Translation:


% 1. Two blocks cannot be at the same location.
false if loc(B1) = B & loc(B2) = B and B1\=B2.

% 2.1 A block is in a tower if it's location is on the table.
in_tower(B) if loc(B) = table.

% 2.2 A block is in a tower if it's location is on something that is in a tower.
in_tower(B) if loc(B) = B1 & in_tower(B1).

% 3. Blocks don't float in the air.
false if ~in_tower(B).

% 4. Moving a block causes it's location to move to loc.
loc(B)=L after move(B,L).

% 5. The move action is impermissible if something is on the location to be moved to.
false after move(B,L) & loc(B1) = B.

% 6. By default, a block is not in the tower.
~in_tower(B) if cons ~in_tower(B).

% 7. The move action causes nothing to be gripped.
gripped(none) if move(B,L).

Program 2

Domain:
:- sorts
    loc >> peg;
    disk.
:- objects
    a,b,c :: peg;
    d1,d2,d3 :: disk.
:- variables
    L, L1, L2 :: loc;
    D, D1, D2 :: disk.
:- constants
    loc(disk) :: inertialFluent(loc);
    inTower(disk) :: inertialFluent;
    move(disk, loc) :: action.

Original rules:
% The location of a disk changes when it is moved.
move(D,L) causes loc(D)=L.

% A disk cannot be moved if it is under another disk.
nonexecutable move(D,L) if inTower(D).

% A disk cannot be moved to a location if there is already a disk at that location.
nonexecutable move(D,L) if loc(D1)=L & D1\=D.

% A disk can only be moved to a location if that location is a peg or the top of a tower.
nonexecutable move(D,L) if ~peg(L) & ~inTower(D1) & loc(D1)=L.

% A disk becomes part of a tower when it is moved to the top of a tower.
move(D,L) causes inTower(D) if inTower(D1) & loc(D1)=L.

% A disk is no longer part of a tower when it is moved from the top of a tower.
move(D,L) causes ~inTower(D) if inTower(D) & loc(D)\=L.

% A disk cannot be moved to a location if the disk is larger than the disk at the top of the tower at that location.
nonexecutable move(D,L) if inTower(D1) & loc(D1)=L & D>D1.

% A disk cannot be moved to a location if the disk is the same size as the disk at the top of the tower at that location.
nonexecutable move(D,L) if inTower(D1) & loc(D1)=L & D=D1.

% It is not permissible to move a disk to a location and move another disk to the same location at the same time.
nonexecutable move(D1,L) & move(D2,L) if D1\=D2.

% It is not permissible to move a disk from a location and move another disk from the same location at the same time.
nonexecutable move(D1,L1) & move(D2,L2) if loc(D1)=loc(D2) & L1\=L2.

Translation:

% The location of a disk changes when it is moved.
loc(D)=L after move(D,L).

% A disk cannot be moved if it is under another disk.
false after move(D,L) & inTower(D).

% A disk cannot be moved to a location if there is already a disk at that location.
false after move(D,L) & loc(D1)=L & D1\=D.

% A disk can only be moved to a location if that location is a peg or the top of a tower.
false after move(D,L) if ~peg(L) & ~inTower(D1) & loc(D1)=L.

% A disk becomes part of a tower when it is moved to the top of a tower.
inTower(D) after move(D,L) & inTower(D1) & loc(D1)=L.

% A disk is no longer part of a tower when it is moved from the top of a tower.
~inTower(D) after move(D,L) & inTower(D) & loc(D)\=L.

% A disk cannot be moved to a location if the disk is larger than the disk at the top of the tower at that location.
false after move(D,L) & inTower(D1) & loc(D1)=L & D>D1.

% A disk cannot be moved to a location if the disk is the same size as the disk at the top of the tower at that location.
false after move(D,L) & inTower(D1) & loc(D1)=L & D=D1.

% It is not permissible to move a disk to a location and move another disk to the same location at the same time.
false after move(D1,L) & move(D2,L) & D1\=D2.

% It is not permissible to move a disk from a location and move another disk from the same location at the same time.
false after move(D1,L1) & move(D2,L2) & loc(D1)=loc(D2) & L1\=L2.","The programming language BC is an action language which has two kinds of constants, a fluent constant and an action constant. An atom is of the form f=v, where f is a fluent constant, and v is an element of its domain. These rules eventuall get translated into another form.

Atoms are generally in the form ""f=v"", but can be written short form ""f"" if it represents a boolean variable, and hence ""v"" is true and false.

Here, we will translate rules and their atoms. If the atom is of the form ""f=v"", then it will be copied as ""holds(f(v),i)"" according to the translation, where v is an element in f's domain. If it is of the form of ""f"", then it will be copied as ""holds(f(v),I)"", where v is either true or false. I is a timestamp.

For example, the atom ""loc(car)=L"" may be translated to ""holds(loc(car, L),I)"", and the atom ""door(open)"" may be translated into ""holds(door(open, true),I)"" or ""holds(door(open,false),I)"" since it is boolean. 

Static laws:

Example:
Original rule: loc(person)=L if inCar & loc(car)=L if cons on(car).
Translation: holds(loc(person,L),I) :- holds(incar(true),I), holds(loc(car,L),I), not not holds(on(car, true),I), timestep(I).

Example:
Original rule: false if hasbrother(C) & ~hasSibling(C).
Translation::- holds(hasbrother(C,true),I), holds(hasSibling(C,false),I), timestep(I).

Dynamic laws:

Example:
Original rule: status(light) = on after switch(on) if cons power(on) & connected.
Translation: holds(status(light,on),I+1) :- holds(switch(on,true),I), not not holds(power(on,true),I+1), not not holds(connected(true),I+1), timestep(I).

Example:
Original rule: false after lift(O) & weight(O)=heavy.
Translation: :- occurs(lift(object),I), holds(weight(O,heavy),I), timestep(I).

Translate the following programs:

Program 1:

BC Domain:
:- sorts
    loc >> block;
    block_w_none >> block;
    machine;
    gripper.

:- objects
    table :: loc;
    b1, b2, b3, b4 :: block;
    m1, m2 :: machine;
    g1, g2, g3 :: gripper.

:- constants
    loc(block) :: inertialFluent(loc);
    gripped :: inertialFluent(block+none);
    in_tower(block) :: sdFluent;
    move(block, loc) :: action.

ASP Domain:

% supersorts
s_loc(B) :- s_block(B).

% sorts
s_boolean(true;false).  

s_loc(table).
s_block(b1;b2;b3;b4).  
s_machine(m1;m2).
s_gripper(g1;g2).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loc(B,V),0)} :- s_block(B), s_loc(V).
{holds(gripper(V),0)} :- s_block_w_none(V).
{holds(in_tower(B,V),0)} :- s_block(B), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(move(B,L),T_step)} :- s_block(B), s_loc(L), timestep(T_step).

% Inertia

{holds(loc(B,V),T_step+1)} :-holds(loc(B,V),T_step), timestep(T_step).
{holds(gripped(V),T_step+1)} :-holds(gripped(V),T_step), timestep(T_step).
{holds(in_tower(B,V),T_step+1)} :-holds(in_tower(B,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint

:- not {holds(loc(B,V),T_step): s_loc(V)}=1, s_block(B), timestep(T_step).
:- not {holds(gripped(V),T_step): s_block_w_none(V)}=1, timestep(T_step).
:- not {holds(in_tower(B,V),T_step): s_boolean(V)}=1, s_block(B), timestep(T_step).


Rules:
% 1. Two blocks cannot be at the same location.
false if loc(B1) = B & loc(B2) = B and B1\=B2.

% 2.1 A block is in a tower if it's location is on the table.
in_tower(B) if loc(B) = table.

% 2.2 A block is in a tower if it's location is on something that is in a tower.
in_tower(B) if loc(B) = B1 & in_tower(B1).

% 3. Blocks don't float in the air.
false if ~in_tower(B).

% 4. Moving a block causes it's location to move to loc.
loc(B)=L after move(B,L).

% 5. The move action is impermissible if something is on the location to be moved to.
false after move(B,L) & loc(B1) = B.

% 6. By default, a block is not in the tower.
~in_tower(B) if cons ~in_tower(B).

% 7. The move action causes nothing to be gripped.
gripped=none if move(B,L).

Translation:
% 1. Two blocks cannot be at the same location.
:- holds(loc(B1,B),T_step), holds(loc(B2,B),T_step), B1!=B2, s_block(B), s_block(B1), s_block(B2), timestep(T_step).

% 2.1 A block is in a tower if it's location is on the table.
holds(in_tower(B,true),T_step) :- holds(loc(B,table),T_step), s_block(B), timestep(T_step).

% 2.2 A block is in a tower if it's location is on something that is in a tower.
holds(in_tower(B,true),T_step) :- holds(loc(B,B1),T_step), holds(in_tower(B1,true),T_step), s_block(B), s_block(B1), timestep(T_step).

% 3. Blocks don't float in the air.
:- holds(in_tower(B,true),T_step), s_block(B), timestep(T_step).

% 4. Moving a block causes it's location to move to loc.
holds(loc(B,L),T_step+1) :- occurs(move(B,L),T_step), s_block(B), s_loc(L), timestep(T_step).

% 5. The move action is impermissible if something is on the location to be moved to.
:- occurs(move(B,L),T_step), holds(loc(B1,B),T_step), s_block(B), s_block(B1), s_loc(L), timestep(T_step).

% 6. By default, a block is not in the tower.
holds(in_tower(B,false),T_step) :- not not holds(in_tower(B,false),T_step), s_block(B), timestep(T_step).

% 7. The move action causes nothing to be gripped.
holds(gripped(none),T_step+1) :- occurs(move(B,L),T_step), s_block(B), s_loc(L).

Program 2:

BC Domain:
:- sorts
    loc >> peg;
    disk.
:- objects
    a,b,c :: peg;
    d1,d2,d3 :: disk.
:- variables
    L, L1, L2 :: loc;
    D, D1, D2 :: disk.
:- constants
    loc(disk) :: inertialFluent(loc);
    inTower(disk) :: inertialFluent;
    move(disk, loc) :: action.

ASP Domain:
% supersorts
s_loc(P) :- s_peg(P).

% sorts
s_boolean(true;false).
s_peg(a;b;c).
s_disk(d1;d2;d3).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loc(D,V),0)} :- s_disk(D), s_loc(V).
{holds(inTower(D,V),0)} :- s_disk(D), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(move(D,L),T_step)} :- s_disk(D), s_loc(L), timestep(T_step).

% Inertia
{holds(loc(D,V),T_step+1)} :-holds(loc(D,V),T_step), timestep(T_step).
{holds(inTower(D,V),T_step+1)} :-holds(inTower(D,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(loc(D,V),T_step): s_loc(V)}=1, s_disk(D), timestep(T_step).
:- not {holds(inTower(D,V),T_step): s_boolean(V)}=1, s_disk(D), timestep(T_step).

Rules:
% The location of a disk changes when it is moved.
loc(D)=L after move(D,L).

% A disk cannot be moved if it is under another disk.
false after move(D,L) & inTower(D).

% A disk cannot be moved to a location if there is already a disk at that location.
false after move(D,L) & loc(D1)=L & D1\=D.

% A disk can only be moved to a location if that location is a peg or the top of a tower.
false after move(D,L) if ~peg(L) & ~inTower(D1) & loc(D1)=L.

% A disk becomes part of a tower when it is moved to the top of a tower.
inTower(D) after move(D,L) & inTower(D1) & loc(D1)=L.

% A disk is no longer part of a tower when it is moved from the top of a tower.
~inTower(D) after move(D,L) & inTower(D) & loc(D)\=L.

% A disk cannot be moved to a location if the disk is larger than the disk at the top of the tower at that location.
false after move(D,L) & inTower(D1) & loc(D1)=L & D>D1.

% A disk cannot be moved to a location if the disk is the same size as the disk at the top of the tower at that location.
false after move(D,L) & inTower(D1) & loc(D1)=L & D=D1.

% It is not permissible to move a disk to a location and move another disk to the same location at the same time.
false after move(D1,L) & move(D2,L) & D1\=D2.

% It is not permissible to move a disk from a location and move another disk from the same location at the same time.
false after move(D1,L1) & move(D2,L2) & loc(D1)=loc(D2) & L1\=L2.

Translation:

% The location of a disk changes when it is moved.
holds(loc(D,L),T_step+1) :- occurs(move(D,L),T_step), s_disk(D), s_loc(L), timestep(T_step).

% A disk cannot be moved if it is under another disk.
:- occurs(move(D,L),T_step), holds(inTower(D,true),T_step), s_disk(D), s_loc(L), timestep(T_step).

% A disk cannot be moved to a location if there is already a disk at that location.
:- occurs(move(D,L),T_step), holds(loc(D1,L),T_step), D1!=D, s_disk(D), s_disk(D1), s_loc(L), timestep(T_step).

% A disk can only be moved to a location if that location is a peg or the top of a tower.
:- occurs(move(D,L),T_step), not s_peg(L), not holds(inTower(D1,true),T_step), holds(loc(D1,L),T_step), s_disk(D), s_disk(D1), s_loc(L), timestep(T_step).

% A disk becomes part of a tower when it is moved to the top of a tower.
holds(inTower(D,true),T_step+1) :- occurs(move(D,L),T_step), holds(inTower(D1,true),T_step), holds(loc(D1,L),T_step), s_disk(D), s_disk(D1), s_loc(L), timestep(T_step).

% A disk is no longer part of a tower when it is moved from the top of a tower.
holds(inTower(D,false),T_step+1) :- occurs(move(D,L),T_step), holds(inTower(D,true),T_step), holds(loc(D,L1),T_step), L!=L1, s_disk(D), s_loc(L), s_loc(L1), timestep(T_step).

% A disk cannot be moved to a location if the disk is larger than the disk at the top of the tower at that location.
:- occurs(move(D,L),T_step), holds(inTower(D1,true),T_step), holds(loc(D1,L),T_step), D>D1, s_disk(D), s_disk(D1), s_loc(L), timestep(T_step).

% A disk cannot be moved to a location if the disk is the same size as the disk at the top of the tower at that location.
:- occurs(move(D,L),T_step), holds(inTower(D1,true),T_step), holds(loc(D1,L),T_step), D=D1, s_disk(D), s_disk(D1), s_loc(L), timestep(T_step).

% It is not permissible to move a disk to a location and move another disk to the same location at the same time.
:- occurs(move(D1,L),T_step), occurs(move(D2,L),T_step), D1!=D2, s_disk(D1), s_disk(D2), s_loc(L), timestep(T_step).

% It is not permissible to move a disk from a location and move another disk from the same location at the same time.
:- occurs(move(D1,L1),T_step), occurs(move(D2,L2),T_step), holds(loc(D1,L),T_step), holds(loc(D2,L),T_step), L1!=L2, s_disk(D1), s_disk(D2), s_loc(L1), s_loc(L2), s_loc(L), timestep(T_step).","Given the domain in ASP, convert the natural language queries into ASP form.

Program 1:

ASP Domain:
% supersorts
s_loc(B) :- s_block(B).

% sorts
s_boolean(true;false).  

s_loc(table).
s_block(b1;b2;b3;b4).  
s_machine(m1;m2).
s_gripper(g1;g2).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loc(B,V),0)} :- s_block(B), s_loc(V).
{holds(gripper(V),0)} :- s_block_w_none(V).
{holds(in_tower(B,V),0)} :- s_block(B), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(move(B,L),T_step)} :- s_block(B), s_loc(L), timestep(T_step).

% Inertia

{holds(loc(B,V),T_step+1)} :-holds(loc(B,V),T_step), timestep(T_step).
{holds(gripped(V),T_step+1)} :-holds(gripped(V),T_step), timestep(T_step).
{holds(in_tower(B,V),T_step+1)} :-holds(in_tower(B,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint

:- not {holds(loc(B,V),T_step): s_loc(V)}=1, s_block(B), timestep(T_step).
:- not {holds(gripped(V),T_step): s_block_w_none(V)}=1, timestep(T_step).
:- not {holds(in_tower(B,V),T_step): s_boolean(V)}=1, s_block(B), timestep(T_step).

Queries:
% Block b1 is on block b2 at time 0.

% Block b3 is moved onto block b4 at time 3.

% At time step 6, block b4 is on b3, b3 is on b2, and b2 is on b1.

ASP form:
% initially, block b1 is on block b2 at time 0.
holds(loc(b1,b2),0).

% block b3 is moved onto block b4 at time 3.
:- not occurs(move(b3),b4),3).

% At time step 6, block b4 is on b3, b3 is on b2, and b2 is on b1.
:- not holds(loc(b4,b3),0).
:- not holds(loc(b3,b2),0).
:- not holds(loc(b2,b1),0).

Program 2:
ASP Domain:
% supersorts
s_loc(P) :- s_peg(P).

% sorts
s_boolean(true;false).
s_peg(a;b;c).
s_disk(d1;d2;d3).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loc(D,V),0)} :- s_disk(D), s_loc(V).
{holds(inTower(D,V),0)} :- s_disk(D), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(move(D,L),T_step)} :- s_disk(D), s_loc(L), timestep(T_step).

% Inertia
{holds(loc(D,V),T_step+1)} :-holds(loc(D,V),T_step), timestep(T_step).
{holds(inTower(D,V),T_step+1)} :-holds(inTower(D,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(loc(D,V),T_step): s_loc(V)}=1, s_disk(D), timestep(T_step).
:- not {holds(inTower(D,V),T_step): s_boolean(V)}=1, s_disk(D), timestep(T_step).

Queries:
 % Initially, disk d1 is in disk d2 at time 0.
% Initially, disk d2 is on disk d3 at time 0.
% Initially, disk d3 is on peg a at time 0.

% Disk d3 is on disk d2 at time 6.
% Disk d2 is on disk d1 at time 6.
% Disk d1 is on peg c at time 6.

ASP form:

% Initially, disk d1 is in disk d2 at time 0.
holds(loc(d1,d2),0).

% Initially, disk d2 is on disk d3 at time 0.
holds(loc(d2,d3),0).

% Initially, disk d3 is on peg a at time 0.
holds(loc(d3,a),0).

% Disk d3 is on disk d2 at time 6.
:- not holds(loc(d3,d2),6).

% Disk d2 is on disk d1 at time 6.
:- not holds(loc(d2,d1),6).

% Disk d1 is on peg c at time 6.
:- not holds(loc(d1,c),6).","


% The location of a disk changes when it is moved.
% A disk cannot be moved if it is under another disk.
% A disk cannot be moved to a location if there is already a disk at that location.
% A disk can only be moved to a location if that location is a peg or the top of a tower.
% A disk becomes part of a tower when it is moved to the top of a tower.
% A disk is no longer part of a tower when it is moved from the top of a tower.
% A disk cannot be moved to a location if the disk is larger than the disk at the top of the tower at that location.
% A disk cannot be moved to a location if the disk is the same size as the disk at the top of the tower at that location.
% It is not permissible to move a disk to a location and move another disk to the same location at the same time.
% It is not permissible to move a disk from a location and move another disk from the same location at the same time.


:- sorts
    loc >> peg;
    disk.
:- objects
    a,b,c :: peg;
    d1,d2,d3 :: disk.
:- variables
    L, L1, L2 :: loc;
    D, D1, D2 :: disk.
:- constants
    loc(disk) :: inertialFluent(loc);
    inTower(disk) :: inertialFluent;
    move(disk, loc) :: action.


% supersorts
s_loc(P) :- s_peg(P).

% sorts
s_boolean(true;false).
s_peg(a;b;c).
s_disk(d1;d2;d3).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loc(D,V),0)} :- s_disk(D), s_loc(V).
{holds(inTower(D,V),0)} :- s_disk(D), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(move(D,L),T_step)} :- s_disk(D), s_loc(L), timestep(T_step).

% Inertia
{holds(loc(D,V),T_step+1)} :-holds(loc(D,V),T_step), timestep(T_step).
{holds(inTower(D,V),T_step+1)} :-holds(inTower(D,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(loc(D,V),T_step): s_loc(V)}=1, s_disk(D), timestep(T_step).
:- not {holds(inTower(D,V),T_step): s_boolean(V)}=1, s_disk(D), timestep(T_step).


% The location of a disk changes when it is moved.
move(D,L) causes loc(D)=L.

% A disk cannot be moved if it is under another disk.
nonexecutable move(D,L) if inTower(D).

% A disk cannot be moved to a location if there is already a disk at that location.
nonexecutable move(D,L) if loc(D1)=L & D1\=D.

% A disk can only be moved to a location if that location is a peg or the top of a tower.
nonexecutable move(D,L) if ~peg(L) & ~inTower(D1) & loc(D1)=L.

% A disk becomes part of a tower when it is moved to the top of a tower.
move(D,L) causes inTower(D) if inTower(D1) & loc(D1)=L.

% A disk is no longer part of a tower when it is moved from the top of a tower.
move(D,L) causes ~inTower(D) if inTower(D) & loc(D)\=L.

% A disk cannot be moved to a location if the disk is larger than the disk at the top of the tower at that location.
nonexecutable move(D,L) if inTower(D1) & loc(D1)=L & D>D1.

% A disk cannot be moved to a location if the disk is the same size as the disk at the top of the tower at that location.
nonexecutable move(D,L) if inTower(D1) & loc(D1)=L & D=D1.

% It is not permissible to move a disk to a location and move another disk to the same location at the same time.
nonexecutable move(D1,L) & move(D2,L) if D1\=D2.

% It is not permissible to move a disk from a location and move another disk from the same location at the same time.
nonexecutable move(D1,L1) & move(D2,L2) if loc(D1)=loc(D2) & L1\=L2.


% The location of a disk changes when it is moved.
loc(D)=L after move(D,L).

% A disk cannot be moved if it is under another disk.
false after move(D,L) & inTower(D).

% A disk cannot be moved to a location if there is already a disk at that location.
false after move(D,L) & loc(D1)=L & D1\=D.

% A disk can only be moved to a location if that location is a peg or the top of a tower.
false after move(D,L) if ~peg(L) & ~inTower(D1) & loc(D1)=L.

% A disk becomes part of a tower when it is moved to the top of a tower.
inTower(D) after move(D,L) & inTower(D1) & loc(D1)=L.

% A disk is no longer part of a tower when it is moved from the top of a tower.
~inTower(D) after move(D,L) & inTower(D) & loc(D)\=L.

% A disk cannot be moved to a location if the disk is larger than the disk at the top of the tower at that location.
false after move(D,L) & inTower(D1) & loc(D1)=L & D>D1.

% A disk cannot be moved to a location if the disk is the same size as the disk at the top of the tower at that location.
false after move(D,L) & inTower(D1) & loc(D1)=L & D=D1.

% It is not permissible to move a disk to a location and move another disk to the same location at the same time.
false after move(D1,L) & move(D2,L) & D1\=D2.

% It is not permissible to move a disk from a location and move another disk from the same location at the same time.
false after move(D1,L1) & move(D2,L2) & loc(D1)=loc(D2) & L1\=L2.


% The location of a disk changes when it is moved.
holds(loc(D,L),T_step+1) :- occurs(move(D,L),T_step), s_disk(D), s_loc(L), timestep(T_step).

% A disk cannot be moved if it is under another disk.
:- occurs(move(D,L),T_step), holds(inTower(D,true),T_step), s_disk(D), s_loc(L), timestep(T_step).

% A disk cannot be moved to a location if there is already a disk at that location.
:- occurs(move(D,L),T_step), holds(loc(D1,L),T_step), D1!=D, s_disk(D), s_disk(D1), s_loc(L), timestep(T_step).

% A disk can only be moved to a location if that location is a peg or the top of a tower.
:- occurs(move(D,L),T_step), not s_peg(L), not holds(inTower(D1,true),T_step), holds(loc(D1,L),T_step), s_disk(D), s_disk(D1), s_loc(L), timestep(T_step).

% A disk becomes part of a tower when it is moved to the top of a tower.
holds(inTower(D,true),T_step+1) :- occurs(move(D,L),T_step), holds(inTower(D1,true),T_step), holds(loc(D1,L),T_step), s_disk(D), s_disk(D1), s_loc(L), timestep(T_step).

% A disk is no longer part of a tower when it is moved from the top of a tower.
holds(inTower(D,false),T_step+1) :- occurs(move(D,L),T_step), holds(inTower(D,true),T_step), holds(loc(D,L1),T_step), L!=L1, s_disk(D), s_loc(L), s_loc(L1), timestep(T_step).

% A disk cannot be moved to a location if the disk is larger than the disk at the top of the tower at that location.
:- occurs(move(D,L),T_step), holds(inTower(D1,true),T_step), holds(loc(D1,L),T_step), D>D1, s_disk(D), s_disk(D1), s_loc(L), timestep(T_step).

% A disk cannot be moved to a location if the disk is the same size as the disk at the top of the tower at that location.
:- occurs(move(D,L),T_step), holds(inTower(D1,true),T_step), holds(loc(D1,L),T_step), D=D1, s_disk(D), s_disk(D1), s_loc(L), timestep(T_step).

% It is not permissible to move a disk to a location and move another disk to the same location at the same time.
:- occurs(move(D1,L),T_step), occurs(move(D2,L),T_step), D1!=D2, s_disk(D1), s_disk(D2), s_loc(L), timestep(T_step).

% It is not permissible to move a disk from a location and move another disk from the same location at the same time.
:- occurs(move(D1,L1),T_step), occurs(move(D2,L2),T_step), holds(loc(D1,L),T_step), holds(loc(D2,L),T_step), L1!=L2, s_disk(D1), s_disk(D2), s_loc(L1), s_loc(L2), s_loc(L), timestep(T_step).


% Initially, disk d1 is in disk d2 at time 0.
holds(loc(d1,d2),0).

% Initially, disk d2 is on disk d3 at time 0.
holds(loc(d2,d3),0).

% Initially, disk d3 is on peg a at time 0.
holds(loc(d3,a),0).

% Disk d3 is on disk d2 at time 6.
:- not holds(loc(d3,d2),6).

% Disk d2 is on disk d1 at time 6.
:- not holds(loc(d2,d1),6).

% Disk d1 is on peg c at time 6.
:- not holds(loc(d1,c),6).",":- sorts
    loc >> peg;
    disk.
:- objects
    a,b,c :: peg;
    d1,d2,d3 :: disk.
:- variables
    L, L1, L2 :: loc;
    D, D1, D2 :: disk.
:- constants
    loc(disk) :: inertialFluent(loc);
    inTower(disk) :: inertialFluent;
    move(disk, loc) :: action.


% The location of a disk changes when it is moved.
move(D,L) causes loc(D)=L.

% A disk cannot be moved if it is under another disk.
nonexecutable move(D,L) if inTower(D).

% A disk cannot be moved to a location if there is already a disk at that location.
nonexecutable move(D,L) if loc(D1)=L & D1\=D.

% A disk can only be moved to a location if that location is a peg or the top of a tower.
nonexecutable move(D,L) if ~peg(L) & ~inTower(D1) & loc(D1)=L.

% A disk becomes part of a tower when it is moved to the top of a tower.
move(D,L) causes inTower(D) if inTower(D1) & loc(D1)=L.

% A disk is no longer part of a tower when it is moved from the top of a tower.
move(D,L) causes ~inTower(D) if inTower(D) & loc(D)\=L.

% A disk cannot be moved to a location if the disk is larger than the disk at the top of the tower at that location.
nonexecutable move(D,L) if inTower(D1) & loc(D1)=L & D>D1.

% A disk cannot be moved to a location if the disk is the same size as the disk at the top of the tower at that location.
nonexecutable move(D,L) if inTower(D1) & loc(D1)=L & D=D1.

% It is not permissible to move a disk to a location and move another disk to the same location at the same time.
nonexecutable move(D1,L) & move(D2,L) if D1\=D2.

% It is not permissible to move a disk from a location and move another disk from the same location at the same time.
nonexecutable move(D1,L1) & move(D2,L2) if loc(D1)=loc(D2) & L1\=L2.","% supersorts
s_loc(P) :- s_peg(P).

% sorts
s_boolean(true;false).
s_peg(a;b;c).
s_disk(d1;d2;d3).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loc(D,V),0)} :- s_disk(D), s_loc(V).
{holds(inTower(D,V),0)} :- s_disk(D), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(move(D,L),T_step)} :- s_disk(D), s_loc(L), timestep(T_step).

% Inertia
{holds(loc(D,V),T_step+1)} :-holds(loc(D,V),T_step), timestep(T_step).
{holds(inTower(D,V),T_step+1)} :-holds(inTower(D,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(loc(D,V),T_step): s_loc(V)}=1, s_disk(D), timestep(T_step).
:- not {holds(inTower(D,V),T_step): s_boolean(V)}=1, s_disk(D), timestep(T_step).


% The location of a disk changes when it is moved.
holds(loc(D,L),T_step+1) :- occurs(move(D,L),T_step), s_disk(D), s_loc(L), timestep(T_step).

% A disk cannot be moved if it is under another disk.
:- occurs(move(D,L),T_step), holds(inTower(D,true),T_step), s_disk(D), s_loc(L), timestep(T_step).

% A disk cannot be moved to a location if there is already a disk at that location.
:- occurs(move(D,L),T_step), holds(loc(D1,L),T_step), D1!=D, s_disk(D), s_disk(D1), s_loc(L), timestep(T_step).

% A disk can only be moved to a location if that location is a peg or the top of a tower.
:- occurs(move(D,L),T_step), not s_peg(L), not holds(inTower(D1,true),T_step), holds(loc(D1,L),T_step), s_disk(D), s_disk(D1), s_loc(L), timestep(T_step).

% A disk becomes part of a tower when it is moved to the top of a tower.
holds(inTower(D,true),T_step+1) :- occurs(move(D,L),T_step), holds(inTower(D1,true),T_step), holds(loc(D1,L),T_step), s_disk(D), s_disk(D1), s_loc(L), timestep(T_step).

% A disk is no longer part of a tower when it is moved from the top of a tower.
holds(inTower(D,false),T_step+1) :- occurs(move(D,L),T_step), holds(inTower(D,true),T_step), holds(loc(D,L1),T_step), L!=L1, s_disk(D), s_loc(L), s_loc(L1), timestep(T_step).

% A disk cannot be moved to a location if the disk is larger than the disk at the top of the tower at that location.
:- occurs(move(D,L),T_step), holds(inTower(D1,true),T_step), holds(loc(D1,L),T_step), D>D1, s_disk(D), s_disk(D1), s_loc(L), timestep(T_step).

% A disk cannot be moved to a location if the disk is the same size as the disk at the top of the tower at that location.
:- occurs(move(D,L),T_step), holds(inTower(D1,true),T_step), holds(loc(D1,L),T_step), D=D1, s_disk(D), s_disk(D1), s_loc(L), timestep(T_step).

% It is not permissible to move a disk to a location and move another disk to the same location at the same time.
:- occurs(move(D1,L),T_step), occurs(move(D2,L),T_step), D1!=D2, s_disk(D1), s_disk(D2), s_loc(L), timestep(T_step).

% It is not permissible to move a disk from a location and move another disk from the same location at the same time.
:- occurs(move(D1,L1),T_step), occurs(move(D2,L2),T_step), holds(loc(D1,L),T_step), holds(loc(D2,L),T_step), L1!=L2, s_disk(D1), s_disk(D2), s_loc(L1), s_loc(L2), s_loc(L), timestep(T_step).


% Initially, disk d1 is in disk d2 at time 0.
holds(loc(d1,d2),0).

% Initially, disk d2 is on disk d3 at time 0.
holds(loc(d2,d3),0).

% Initially, disk d3 is on peg a at time 0.
holds(loc(d3,a),0).

% Disk d3 is on disk d2 at time 6.
:- not holds(loc(d3,d2),6).

% Disk d2 is on disk d1 at time 6.
:- not holds(loc(d2,d1),6).

% Disk d1 is on peg c at time 6.
:- not holds(loc(d1,c),6)."
switches prompts,"Two light switches can each be flipped, but only one can be on at a time.
----------------------------------------------------------------------



% The switch s1 is on at time step 0.
% The switch s2 is on at time step 3.

","Given a description of a problem, write commonsense knowledge about the domain that we would expect. These represent logical constraints in the problem.

For example, a task about moving objects would involve some knowledge about what is required to move, what the effect of moving an object does, such as the location of the object changing or its previous location now being empty. 

These restrictions and effects are dependent on the context of the problem. Here we list some example problems and extract commonsense knowledge.

Problem 1
Description:
A monkey wants to get a bunch of bananas hanging from the ceiling. He can reach the bananas by first pushing a box to the empty place under the bananas and then climbing on top of the box. The task is to come up with a plan for retrieving the bananas.
Some things to consider are the monkey, the bananas, the box, the location of objects, and the monkey's ability to move and push the box. Provide the relevant commonsense knowledge. Only use the terminology in the hint to write the commonsense knowledge.

Hint:
There are two main types of things: ""things"" and ""location"".

monkey, bananas, and box are things.
l1, l2, and l3 are locations.

Fluents:
A (thing)'s location is a simple fluent (location).
Having bananas is a simple fluent (boolean).
Being on the box are simple fluents (boolean).

Actions:
walk to a (location)
push box to a (location)
climb on
climb off
grasp bananas

Commonsense knowledge (do not provide any extra knowledge that is not included in the description):
% The location of the bananas is where the monkey is if the monkey has bananas.
% The location of the monkey is where the box is if the monkey is on the box.
% Walking to a location causes the monkey’s location to change.
% Walking is not permissible to a location if the monkey is already in that location
% Walking is not permissible if the monkey is on the box.
% Pushing the box to a location causes the location of the box to move.
% Pushing the box to a location causes the location f the monkey to move.
% Pushing the box is not permissible to a location if the monkey is at that location
% Pushing the box is not permissible if the monkey is on the box.
% Pushing the box is not permissible if the location of the monkey is not the same as the location of the box.
% Climbing on the box causes the monkey to be on the box.
% Climbing on the box is not permissible if the monkey is already on the box.
% Climbing on the box is not permissible if the location of the monkey is not the same as the box.
% Climbing off of the box causes the monkey to not be on the box.
% Climbing off of the box is not permissible if the monkey is not on the box.
% Grasping the bananas causes the monkey to have the bananas.
% Grasping the bananas is not permissible if the monkey already has the bananas.
% Grasping the bananas is not permissible if the monkey is not on the box.
% Grasping the bananas is not permissible if the location of the monkey is not the same as the location of the bananas.
% It is not permissible to both walk to a location and push the box to a location.
% It is not permissible to both walk to a location and climb on the box.
% It is not permissible to both push the box to a location and climb on the box.
% It is not permissible to both climb off of the box and grasp the bananas.

Problem 2:
Description:
Two light switches can each be flipped, but only one can be on at a time.

Hint:
There are tqo main types of things: ""switch"" and ""switch_direction"".

s1 and s2 are switches.
up and down are switch directions.

Fluents:
A (switch)'s status is an inertial fluent (switch_direction).

Actions:
Flip a (switch)
Commonsense knowledge (do not provide any extra knowledge that is not included in the description):

% Flipping a switch changes its status.
% If a switch is flipped to 'up', the other switch must be 'down'.
% If a switch is flipped to 'down', the other switch can be either 'up' or 'down'.
% It is not permissible to flip a switch that is already in the intended direction.
% It is not permissible to flip both switches at the same time.","Action language BC specifies the syntax of the domain in the form of sorts, objects, variables, and constants. 

A sort is a named set of elements which is used to specify the domain of each constant and variable. First the sort is declared
using a sort declaration statement and, later, is defined by adding objects to it in an object declaration statement.

Sort declaration:
:- sorts
    int;
    box.

This declares the domains: int, and box.

An object is a value in a sort which a constant can take. It is also used
in parameter lists to construct nested objects and sets of constants. 

Object declaration:
:- objects
    1..3 :: int;
    o(int, int) :: box.

This declares 1,2, and 3 as objects within int, and the objects:
o(1, 1), o(1, 2), o(1, 3),
o(2, 1), o(2, 2), o(2, 3),
o(3, 1), o(3, 2), and o(3, 3),
as values within box.

A variable is a placeholder symbol which will be replaced with each object in its domain during grounding.

Variable declaration:
:- variables
    I, I1, I2 :: int;
    B, B1, B2 :: box.
This declares the variables I, I1, and I2 over the objects within int, and variables B, B1, and B2 range over the objects within box.

Constant symbols are the basic components of multivalued formulas. Similar to object symbols, constants are defined within a constant declaration statement and have a base identifier, an optional list of parameter sort, and a sort which makes up the constant’s domain. In addition, they may have a constant declaration type, such as ""action"", ""simpleFluent"", and ""inertialFluent"". Inertial fluents are used for constants whose value persists through time unless affected otherwise.
Constant declaration:
:- constants
    p(int) :: inertialFluent;
    move(box) :: action.
This declares the inertial fluent p which takes an int argument, and the action move, which takes a box argument.

Given some knowledge about a domain, produce the sorts, objects, variables, and constants for the action language BC. 

Problem 1
Problem description:
A monkey wants to get a bunch of bananas hanging from the ceiling. He can reach the bananas by first pushing a box to the empty place under the bananas and then climbing on top of the box.

Hint:
There are three main types of things: ""monkey"", ""thing"" and ""location"".
""thing"" includes ""monkey"".

monkey, bananas, and box are things.
l1, l2, and l3 are locations.

Fluents:
A (thing)'s location is a simple fluent (location).
Having bananas is a simple fluent (boolean).
Being on the box are simple fluents (boolean).

Actions:
walk to a (location)
push box to a (location)
climb on
climb off
grasp bananas

Knowledge:
% The location of the bananas is where the monkey is if the monkey has bananas.
% The location of the monkey is where the box is if the monkey is on the box.
% Walking to a location causes the monkey’s location to change.
% Walking is not permissible to a location if the monkey is already in that location
% Walking is not permissible if the monkey is on the box.
% Pushing the box to a location causes the location of the box to move.
% Pushing the box to a location causes the location f the monkey to move.
% Pushing the box is not permissible to a location if the monkey is at that location
% Pushing the box is not permissible if the monkey is on the box.
% Pushing the box is not permissible if the location of the monkey is not the same as the location of the box.
% Climbing on the box causes the monkey to be on the box.
% Climbing on the box is not permissible if the monkey is already on the box.
% Climbing on the box is not permissible if the location of the monkey is not the same as the box.
% Climbing off of the box causes the monkey to not be on the box.
% Climbing off of the box is not permissible if the monkey is not on the box.
% Grasping the bananas causes the monkey to have the bananas.
% Grasping the bananas is not permissible if the monkey already has the bananas.
% Grasping the bananas is not permissible if the monkey is not on the box.
% Grasping the bananas is not permissible if the location of the monkey is not the same as the location of the bananas.
% It is not permissible to both walk to a location and push the box to a location.
% It is not permissible to both walk to a location and climb on the box.
% It is not permissible to both push the box to a location and climb on the box.
% It is not permissible to both climb off of the box and grasp the bananas.

BC domain syntax:
:- sorts
    thing >> monkey;
    location.
:- objects
    monkey,bananas,box :: thing;
    l1,l2,l3 :: location.
:- variables
    Loc, Loc1, Loc2 :: location;
    Bool, Bool1, Bool2 :: boolean.
:- constants
    loc(thing) :: simpleFluent(location);
    hasBananas,onBox :: simpleFluent;
    walk(location) :: action;
    pushBox(location) :: action;
    climbOn :: action;
    climbOff :: action;
    graspBananas :: action.


Problem 2
Problem description:
Two light switches can each be flipped, but only one can be on at a time.

Hint:
There are tqo main types of things: ""switch"" and ""switch_direction"".

s1 and s2 are switches.
up and down are switch directions.

Fluents:
A (switch)'s status is an inertial fluent (switch_direction).

Actions:
Flip a (switch)

Knowledge:
% Flipping a switch changes its status.
% If a switch is flipped to 'up', the other switch must be 'down'.
% If a switch is flipped to 'down', the other switch can be either 'up' or 'down'.
% It is not permissible to flip a switch that is already in the intended direction.
% It is not permissible to flip both switches at the same time.

BC domain syntax:

:- sorts
    switch;
    switch_direction.
:- objects
    s1,s2 :: switch;
    up,down :: switch_direction.
:- variables
    S, S1, S2 :: switch;
    SD, SD1, SD2 :: switch_direction.
:- constants
    status(switch) :: inertialFluent(switch_direction);
    flip(switch) :: action.","The programming language BC is an action language which has two kinds of constants, a fluent constant and an action constant. Answer Set Programming (ASP) is a logic programming paradigm. Given a domain specification in BC, generate ASP code which represents the supersorts (if applicable), sorts, choice rule for every fluent constant, choice rule for every action constant, inertial rules, and the uniqueness/existence constraint for each atom.
s_boolean(true;false) represents the boolean values true and false and is always used.
Write the constraints according to the given domains into BC:

Program 1:

Domain:
:- sorts
    loc >> block;
    block_w_none >> block;
    machine;
    gripper.

:- objects
    table :: loc;
    b1, b2, b3, b4 :: block;
    none :: block_w_none;
    m1, m2 :: machine;
    g1, g2, g3 :: gripper.

:- constants
    loc(block) :: inertialFluent(loc);
    gripped :: inertialFluent(block_w_none);
    in_tower(block) :: sdFluent;
    move(block, loc) :: action.

:-variables
    B, B1, B2 :: block;
    B_none :: block_w_none;
    L, L1 :: loc.


Generated constraints:

% supersorts
s_loc(B) :- s_block(B).
s_block_w_none :- s_block(B).

% sorts
s_boolean(true;false).
s_block_w_none(none).

s_loc(table).
s_block(b1;b2;b3;b4).
s_machine(m1;m2).
s_gripper(g1;g2).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loc(B,V),0)} :- s_block(B), s_loc(V).
{holds(gripped(V),0)} :- s_block_w_none(V).
{holds(in_tower(B,V),0)} :- s_block(B), s_boolean(V).


% choice rule {i:a} for every action constant a and every i < l
{occurs(move(B,L),T_step)} :- s_block(B), s_loc(L), timestep(T_step).

% Inertia

{holds(loc(B,V),T_step+1)} :-holds(loc(B,V),T_step), timestep(T_step).
{holds(gripped(V),T_step+1)} :-holds(gripped(V),T_step), timestep(T_step).
{holds(in_tower(B,V),T_step+1)} :-holds(in_tower(B,V),T_step), timestep(T_step).


% existence and uniqueness of value constraint

:- not {holds(loc(B,V),T_step): s_loc(V)}=1, s_block(B), timestep(T_step).
:- not {holds(gripped(V),T_step): s_block_w_none(V)}=1, timestep(T_step).
:- not {holds(in_tower(B,V),T_step): s_boolean(V)}=1, s_block(B), timestep(T_step).

Program 2:

Domain:
:- sorts
    switch;
    switch_direction.
:- objects
    s1,s2 :: switch;
    up,down :: switch_direction.
:- variables
    S, S1, S2 :: switch;
    SD, SD1, SD2 :: switch_direction.
:- constants
    status(switch) :: inertialFluent(switch_direction);
    flip(switch) :: action.

Generated constraints:

% supersorts
% No supersorts in this domain

% sorts
s_boolean(true;false).
s_switch(s1;s2).
s_switch_direction(up;down).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(status(S,V),0)} :- s_switch(S), s_switch_direction(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(flip(S),T_step)} :- s_switch(S), timestep(T_step).

% Inertia
{holds(status(S,V),T_step+1)} :-holds(status(S,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(status(S,V),T_step): s_switch_direction(V)}=1, s_switch(S), timestep(T_step).","A program in BC consists of causal rules of the following 2 forms where their readings are shown after ""%"".
There are two kinds of constants, a fluent constant and an action constant. An  atom is of the form f=v, where f is a fluent constant, and v is an element of its domain. A fluent which has no argument, such as ""hasGas"" is assumed to be boolean. 

An expression of the form:
A_0 if A_1 & A_2 & ... & A_n

where A_i are atoms, expresses the static law that A_0 is true if the conjunction of A_1 & ... & A_n is true.

Example:
% The location of a person is the same as the car if the person is in the car.
loc(person)=L if inCar & loc(car)=L.
Note that the head of the rule (loc(person)=L in the example), must be only a single atom. So the following rule is not valid:
loc(person)=loc(car) if inCar.

An expression of the form:
F causes G if H

where  F is an action, G is an atom and H is a conjunction of atoms, expresses that action F causes G to be true if H is true. 

It also stands for the fluent dynamic law:
caused G after F & H
which expresses that atom G is causes after action F and atom H are true.

Example:
open(D) causes opened(D) if available(D).

Here are some common ways to write rules.

An expression of the form:
impossible A_1 & A_2 & ... & A_n

where A_i are atoms, is used to express that the conjunction of A_i is impossible.

Example:
impossible hasbrother(C) & ~hasSibling(C).
(note that impossible must only have conjunction (&), and cannot contain ""if"")
The form ""impossible A_1 if ..."" is incorrect while ""impossible A_1 & ..."" is correct.

For example, the following is incorrect:
impossible hasbrother(C) if ~hasSibling(C).

An expression of the form:
nonexecutable a_1 & ... & a_n if A_1 & A_2 & ... & A_m.

where a_i are actions and A_i are atoms, is used to express that an action cannot be executed if the conjunction of A_i is true.

Examples:
% It is not permissible to drive a car if it has no gas.
nonexecutable driveCar if ~hasGas.
% It is not permissible to lift an object if it is heavy.
nonexecutable lift(object) if heavy(object).

Example:
default onTable(B) if block(B). 

Examples
default door(open) if door(unlocked) after push(door).

In general, if something cannot be true, then we use ""impossible"" when writing the rules, but if instead we want to assert something is not true, then we use the negation (~). For example, if it is impossible for an object to be on the table and under it, we might write ""impossible onTable(object) & underTable(object)."", but express that if it rains outside the ground is not wet as ""~groundWet if noRain"".
Additionally, ""impossible"" is reserved only for fluents, while ""nonexecutable"" is only reserved for actions.

Here is an example representation.
Problem 1:
:- sorts
    thing;
    location.
:- objects
    monkey,bananas,box :: thing;
    l1,l2,l3 :: location.
:- variables
    Loc, Loc1, Loc2 :: location;
    Bool, Bool1, Bool2 :: boolean.
:- constants
    loc(thing) :: simpleFluent(location);
    hasBananas,onBox :: simpleFluent;
    walk(location) :: action;
    pushBox(location) :: action;
    climbOn :: action;
    climbOff :: action;
    graspBananas :: action.

Represent the following constraints:
% The location of the bananas is where the monkey is if the monkey has bananas.
% The location of the monkey is where the box is if the monkey is on the box.
% The monkey cannot be in two places at once.
% Walking to a location causes the monkey’s location to change.
% Walking is not permissible to a location if the monkey is already in that location
% Walking is not permissible if the monkey is on the box.
% Pushing the box to a location causes the location of the box to move.
% Pushing the box to a location causes the location of the monkey to move.
% Pushing the box is not permissible to a location if the monkey is at that location
% Pushing the box is not permissible if the monkey is on the box.
% Pushing the box is not permissible if the location of the monkey is not the same as the location of the box.
% Climbing on the box causes the monkey to be on the box.
% Climbing on the box is not permissible if the monkey is already on the box.
% Climbing on the box is not permissible if the location of the monkey is not the same as the box.
% Climbing off of the box causes the monkey to not be on the box.
% Climbing off of the box is not permissible if the monkey is not on the box.
% Grasping the bananas causes the monkey to have the bananas.
% Grasping the bananas is not permissible if the monkey already has the bananas.
% Grasping the bananas is not permissible if the monkey is not on the box.
% Grasping the bananas is not permissible if the location of the monkey is not the same as the location of the bananas.
% It is not permissible to both walk to a location and push the box to a location.
% It is not permissible to both walk to a location and climb on the box.
% It is not permissible to both push the box to a location and climb on the box.
% It is not permissible to both climb off of the box and grasp the bananas.

Constraints (only use fluents and actions specified for the problem):
% The location of the bananas is where the monkey is if the monkey has bananas.
loc(bananas)=L if hasBananas & loc(monkey)=L.

% The location of the monkey is where the box is if the monkey is on the box.
loc(monkey)=L if onBox & loc(box)=L.

% The monkey cannot be in two places at once.
impossible loc(monkey) = L1 & loc(monkey)=L2 & L1\=L2.

% Walking to a location causes the monkey’s location to change.
walk(L) causes loc(monkey)=L.

% Walking is not permissible to a location if the monkey is already in that location
nonexecutable walk(L) if loc(monkey)=L.

% Walking is not permissible if the monkey is on the box.
nonexecutable walk(L) if onBox.

% Pushing the box to a location causes the location of the box to move.
pushBox(L) causes loc(box)=L.

% Pushing the box to a location causes the location of the monkey to move.
pushBox(L) causes loc(monkey)=L.

% Pushing the box is not permissible to a location if the monkey is at that location
nonexecutable pushBox(L) if loc(monkey)=L.

% Pushing the box is not permissible if the monkey is on the box.
nonexecutable pushBox(L) if onBox.

% Pushing the box is not permissible if the location of the monkey is not the same as the location of the box.
nonexecutable pushBox(L) if loc(monkey)\=loc(box).

% Climbing on the box causes the monkey to be on the box.
climbOn causes onBox.

% Climbing on the box is not permissible if the monkey is already on the box.
nonexecutable climbOn if onBox.

% Climbing on the box is not permissible if the location of the monkey is not the same as the box.
nonexecutable climbOn if loc(monkey)\=loc(box).

% Climbing off of the box causes the monkey to not be on the box.
climbOff causes ~onBox.

% Climbing off of the box is not permissible if the monkey is not on the box.
nonexecutable climbOff if ~onBox.

% Grasping the bananas causes the monkey to have the bananas.
graspBananas causes hasBananas.

% Grasping the bananas is not permissible if the monkey already has the bananas.
nonexecutable graspBananas if hasBananas.

% Grasping the bananas is not permissible if the monkey is not on the box.
nonexecutable graspBananas if ~onBox.

% Grasping the bananas is not permissible if the location of the monkey is not the same as the location of the bananas.
nonexecutable graspBananas if loc(monkey)\=loc(bananas).

% It is not permissible to both walk to a location and push the box to a location.
nonexecutable walk(L) & pushBox(L).

% It is not permissible to both walk to a location and climb on the box.
nonexecutable walk(L) & climbOn.

% It is not permissible to both push the box to a location and climb on the box.
nonexecutable pushBox(L) & climbOn.

% It is not permissible to both climb off of the box and grasp the bananas.
nonexecutable climbOff & graspBananas.

Problem 2:
Given the following domain:
:- sorts
    switch;
    switch_direction.
:- objects
    s1,s2 :: switch;
    up,down :: switch_direction.
:- variables
    S, S1, S2 :: switch;
    SD, SD1, SD2 :: switch_direction.
:- constants
    status(switch) :: inertialFluent(switch_direction);
    flip(switch) :: action.

Write the following constraints:
% Flipping a switch changes its status.
% If a switch is flipped to 'up', the other switch must be 'down'.
% If a switch is flipped to 'down', the other switch can be either 'up' or 'down'.
% It is not permissible to flip a switch that is already in the intended direction.
% It is not permissible to flip both switches at the same time.

Constraints (only use fluents and actions specified for the problem):

% Flipping a switch changes its status.
flip(S) causes status(S)=up if status(S)=down.
flip(S) causes status(S)=down if status(S)=up.

% If a switch is flipped to 'up', the other switch must be 'down'.
flip(S1) causes status(S2)=down if status(S1)=up & S1\=S2.

% If a switch is flipped to 'down', the other switch can be either 'up' or 'down'.
% This is already covered by the default behavior of the switches and does not need a specific rule.

% It is not permissible to flip a switch that is already in the intended direction.
nonexecutable flip(S) if status(S)=up.
nonexecutable flip(S) if status(S)=down.

% It is not permissible to flip both switches at the same time.
nonexecutable flip(S1) & flip(S2).","The programming language BC is an action language which has two kinds of constants, a fluent constant and an action constant. An atom is of the form f=v, where f is a fluent constant, and v is an element of its domain. There are some shorthand rules which are described below. The shorthand versions expand into another form via a translation.


Rules in this form are not changed.
Example: 
Original rule: loc(person)=L if inCar & loc(car)=L.
Translation: loc(person)=L if inCar & loc(car)=L.


Example:
Original rule: status(light) = on after switch(on).
Translation: status(light) = on after switch(on).

ACTIONS

Example:
Original rule: drive(C,L) causes loc(C) = L.
Translation: loc(C)=L after drive(C,L).

Example:
Original rule: loc(car) = home & drive(home) & loc(car) = bank.
Translation: loc(car)  = home after drive(home) & loc(car) = bank.

DEFAULTS

Example:
Original Rule: default onTable(B) if color(B)=red.
Translation: onTable(B) if color(B) if cons onTable(B).

Example:
Original rule: default ~onTable(B) if pickedUp(B).
Translation: ~onTable(B) after pickedUp(B) if cons ~onTable(B).

IMPOSSIBLE

Example:
Original rule: impossible hasbrother(C) & ~hasSibling(C).
Translation: false if hasbrother(C) & ~hasSibling(C).

NONEXECUTABLE

Example:
Original rule: nonexecutable lift(object) if weight(object)=heavy.
Translation: false after lift(object) & weight(object)=heavy.

Translate the following programs:

Program 1

Domain:
:- sorts
    loc >> block;
    block_w_none >> block;
    machine;
    gripper.

:- objects
    table :: loc;
    b1, b2, b3, b4 :: block;
    m1, m2 :: machine;
    g1, g2, g3 :: gripper.

:- constants
    loc(block) :: inertialFluent(loc);
    gripped :: inertialFluent(block+none);
    in_tower(block) :: sdFluent;
    move(block, loc) :: action.

:-variables
    B, B1, B2 :: block;
    L, L1 :: loc.

Original rules:
% 1. Two blocks cannot be at the same location.
impossible loc(B1) = B & loc(B2) = B & B1\=B2.

% 2.1 A block is in a tower if it's location is on the table.
in_tower(B) if loc(B) = table.

% 2.2 A block is in a tower if it's location is on something that is in a tower.
in_tower(B) if loc(B) = B1 & in_tower(B1).

% 3. Blocks don't float in the air.
impossible ~in_tower(B).

% 4. Moving a block causes it's location to move to loc.
move(B,L) causes loc(B)=L.

% 5. The move action is impermissible if something is on the location to be moved to.
nonexecutable move(B,L) if loc(B1) = B.

% 6. By default, a block is not in the tower.
default ~in_tower(B).

% 7. The move action causes nothing to be gripped.
move(B,L) causes gripped(none).

Translation:


% 1. Two blocks cannot be at the same location.
false if loc(B1) = B & loc(B2) = B and B1\=B2.

% 2.1 A block is in a tower if it's location is on the table.
in_tower(B) if loc(B) = table.

% 2.2 A block is in a tower if it's location is on something that is in a tower.
in_tower(B) if loc(B) = B1 & in_tower(B1).

% 3. Blocks don't float in the air.
false if ~in_tower(B).

% 4. Moving a block causes it's location to move to loc.
loc(B)=L after move(B,L).

% 5. The move action is impermissible if something is on the location to be moved to.
false after move(B,L) & loc(B1) = B.

% 6. By default, a block is not in the tower.
~in_tower(B) if cons ~in_tower(B).

% 7. The move action causes nothing to be gripped.
gripped(none) if move(B,L).

Program 2

Domain:
:- sorts
    switch;
    switch_direction.
:- objects
    s1,s2 :: switch;
    up,down :: switch_direction.
:- variables
    S, S1, S2 :: switch;
    SD, SD1, SD2 :: switch_direction.
:- constants
    status(switch) :: inertialFluent(switch_direction);
    flip(switch) :: action.

Original rules:
% Flipping a switch changes its status.
flip(S) causes status(S)=up if status(S)=down.
flip(S) causes status(S)=down if status(S)=up.

% If a switch is flipped to 'up', the other switch must be 'down'.
flip(S1) causes status(S2)=down if status(S1)=up & S1\=S2.

% If a switch is flipped to 'down', the other switch can be either 'up' or 'down'.
% This is already covered by the default behavior of the switches and does not need a specific rule.

% It is not permissible to flip a switch that is already in the intended direction.
nonexecutable flip(S) if status(S)=up.
nonexecutable flip(S) if status(S)=down.

% It is not permissible to flip both switches at the same time.
nonexecutable flip(S1) & flip(S2).

Translation:

% Flipping a switch changes its status.
status(S)=up after flip(S) if status(S)=down.
status(S)=down after flip(S) if status(S)=up.

% If a switch is flipped to 'up', the other switch must be 'down'.
status(S2)=down after flip(S1) if status(S1)=up & S1\=S2.

% It is not permissible to flip a switch that is already in the intended direction.
false after flip(S) if status(S)=up.
false after flip(S) if status(S)=down.

% It is not permissible to flip both switches at the same time.
false if flip(S1) & flip(S2).","The programming language BC is an action language which has two kinds of constants, a fluent constant and an action constant. An atom is of the form f=v, where f is a fluent constant, and v is an element of its domain. These rules eventuall get translated into another form.

Atoms are generally in the form ""f=v"", but can be written short form ""f"" if it represents a boolean variable, and hence ""v"" is true and false.

Here, we will translate rules and their atoms. If the atom is of the form ""f=v"", then it will be copied as ""holds(f(v),i)"" according to the translation, where v is an element in f's domain. If it is of the form of ""f"", then it will be copied as ""holds(f(v),I)"", where v is either true or false. I is a timestamp.

For example, the atom ""loc(car)=L"" may be translated to ""holds(loc(car, L),I)"", and the atom ""door(open)"" may be translated into ""holds(door(open, true),I)"" or ""holds(door(open,false),I)"" since it is boolean. 

Static laws:

Example:
Original rule: loc(person)=L if inCar & loc(car)=L if cons on(car).
Translation: holds(loc(person,L),I) :- holds(incar(true),I), holds(loc(car,L),I), not not holds(on(car, true),I), timestep(I).

Example:
Original rule: false if hasbrother(C) & ~hasSibling(C).
Translation::- holds(hasbrother(C,true),I), holds(hasSibling(C,false),I), timestep(I).

Dynamic laws:

Example:
Original rule: status(light) = on after switch(on) if cons power(on) & connected.
Translation: holds(status(light,on),I+1) :- holds(switch(on,true),I), not not holds(power(on,true),I+1), not not holds(connected(true),I+1), timestep(I).

Example:
Original rule: false after lift(O) & weight(O)=heavy.
Translation: :- occurs(lift(object),I), holds(weight(O,heavy),I), timestep(I).

Translate the following programs:

Program 1:

BC Domain:
:- sorts
    loc >> block;
    block_w_none >> block;
    machine;
    gripper.

:- objects
    table :: loc;
    b1, b2, b3, b4 :: block;
    m1, m2 :: machine;
    g1, g2, g3 :: gripper.

:- constants
    loc(block) :: inertialFluent(loc);
    gripped :: inertialFluent(block+none);
    in_tower(block) :: sdFluent;
    move(block, loc) :: action.

ASP Domain:

% supersorts
s_loc(B) :- s_block(B).

% sorts
s_boolean(true;false).  

s_loc(table).
s_block(b1;b2;b3;b4).  
s_machine(m1;m2).
s_gripper(g1;g2).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loc(B,V),0)} :- s_block(B), s_loc(V).
{holds(gripper(V),0)} :- s_block_w_none(V).
{holds(in_tower(B,V),0)} :- s_block(B), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(move(B,L),T_step)} :- s_block(B), s_loc(L), timestep(T_step).

% Inertia

{holds(loc(B,V),T_step+1)} :-holds(loc(B,V),T_step), timestep(T_step).
{holds(gripped(V),T_step+1)} :-holds(gripped(V),T_step), timestep(T_step).
{holds(in_tower(B,V),T_step+1)} :-holds(in_tower(B,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint

:- not {holds(loc(B,V),T_step): s_loc(V)}=1, s_block(B), timestep(T_step).
:- not {holds(gripped(V),T_step): s_block_w_none(V)}=1, timestep(T_step).
:- not {holds(in_tower(B,V),T_step): s_boolean(V)}=1, s_block(B), timestep(T_step).


Rules:
% 1. Two blocks cannot be at the same location.
false if loc(B1) = B & loc(B2) = B and B1\=B2.

% 2.1 A block is in a tower if it's location is on the table.
in_tower(B) if loc(B) = table.

% 2.2 A block is in a tower if it's location is on something that is in a tower.
in_tower(B) if loc(B) = B1 & in_tower(B1).

% 3. Blocks don't float in the air.
false if ~in_tower(B).

% 4. Moving a block causes it's location to move to loc.
loc(B)=L after move(B,L).

% 5. The move action is impermissible if something is on the location to be moved to.
false after move(B,L) & loc(B1) = B.

% 6. By default, a block is not in the tower.
~in_tower(B) if cons ~in_tower(B).

% 7. The move action causes nothing to be gripped.
gripped=none if move(B,L).

Translation:
% 1. Two blocks cannot be at the same location.
:- holds(loc(B1,B),T_step), holds(loc(B2,B),T_step), B1!=B2, s_block(B), s_block(B1), s_block(B2), timestep(T_step).

% 2.1 A block is in a tower if it's location is on the table.
holds(in_tower(B,true),T_step) :- holds(loc(B,table),T_step), s_block(B), timestep(T_step).

% 2.2 A block is in a tower if it's location is on something that is in a tower.
holds(in_tower(B,true),T_step) :- holds(loc(B,B1),T_step), holds(in_tower(B1,true),T_step), s_block(B), s_block(B1), timestep(T_step).

% 3. Blocks don't float in the air.
:- holds(in_tower(B,true),T_step), s_block(B), timestep(T_step).

% 4. Moving a block causes it's location to move to loc.
holds(loc(B,L),T_step+1) :- occurs(move(B,L),T_step), s_block(B), s_loc(L), timestep(T_step).

% 5. The move action is impermissible if something is on the location to be moved to.
:- occurs(move(B,L),T_step), holds(loc(B1,B),T_step), s_block(B), s_block(B1), s_loc(L), timestep(T_step).

% 6. By default, a block is not in the tower.
holds(in_tower(B,false),T_step) :- not not holds(in_tower(B,false),T_step), s_block(B), timestep(T_step).

% 7. The move action causes nothing to be gripped.
holds(gripped(none),T_step+1) :- occurs(move(B,L),T_step), s_block(B), s_loc(L).

Program 2:

BC Domain:
:- sorts
    switch;
    switch_direction.
:- objects
    s1,s2 :: switch;
    up,down :: switch_direction.
:- variables
    S, S1, S2 :: switch;
    SD, SD1, SD2 :: switch_direction.
:- constants
    status(switch) :: inertialFluent(switch_direction);
    flip(switch) :: action.

ASP Domain:
% supersorts
% No supersorts in this domain

% sorts
s_boolean(true;false).
s_switch(s1;s2).
s_switch_direction(up;down).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(status(S,V),0)} :- s_switch(S), s_switch_direction(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(flip(S),T_step)} :- s_switch(S), timestep(T_step).

% Inertia
{holds(status(S,V),T_step+1)} :-holds(status(S,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(status(S,V),T_step): s_switch_direction(V)}=1, s_switch(S), timestep(T_step).

Rules:
% Flipping a switch changes its status.
status(S)=up after flip(S) if status(S)=down.
status(S)=down after flip(S) if status(S)=up.

% If a switch is flipped to 'up', the other switch must be 'down'.
status(S2)=down after flip(S1) if status(S1)=up & S1\=S2.

% It is not permissible to flip a switch that is already in the intended direction.
false after flip(S) if status(S)=up.
false after flip(S) if status(S)=down.

% It is not permissible to flip both switches at the same time.
false if flip(S1) & flip(S2).

Translation:

% Flipping a switch changes its status.
holds(status(S,up),T_step+1) :- occurs(flip(S),T_step), holds(status(S,down),T_step), s_switch(S), timestep(T_step).
holds(status(S,down),T_step+1) :- occurs(flip(S),T_step), holds(status(S,up),T_step), s_switch(S), timestep(T_step).

% If a switch is flipped to 'up', the other switch must be 'down'.
holds(status(S2,down),T_step+1) :- occurs(flip(S1),T_step), holds(status(S1,up),T_step), S1!=S2, s_switch(S1), s_switch(S2), timestep(T_step).

% It is not permissible to flip a switch that is already in the intended direction.
:- occurs(flip(S),T_step), holds(status(S,up),T_step), s_switch(S), timestep(T_step).
:- occurs(flip(S),T_step), holds(status(S,down),T_step), s_switch(S), timestep(T_step).

% It is not permissible to flip both switches at the same time.
:- occurs(flip(S1),T_step), occurs(flip(S2),T_step), s_switch(S1), s_switch(S2), timestep(T_step).","Given the domain in ASP, convert the natural language queries into ASP form.

Program 1:

ASP Domain:
% supersorts
s_loc(B) :- s_block(B).

% sorts
s_boolean(true;false).  

s_loc(table).
s_block(b1;b2;b3;b4).  
s_machine(m1;m2).
s_gripper(g1;g2).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(loc(B,V),0)} :- s_block(B), s_loc(V).
{holds(gripper(V),0)} :- s_block_w_none(V).
{holds(in_tower(B,V),0)} :- s_block(B), s_boolean(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(move(B,L),T_step)} :- s_block(B), s_loc(L), timestep(T_step).

% Inertia

{holds(loc(B,V),T_step+1)} :-holds(loc(B,V),T_step), timestep(T_step).
{holds(gripped(V),T_step+1)} :-holds(gripped(V),T_step), timestep(T_step).
{holds(in_tower(B,V),T_step+1)} :-holds(in_tower(B,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint

:- not {holds(loc(B,V),T_step): s_loc(V)}=1, s_block(B), timestep(T_step).
:- not {holds(gripped(V),T_step): s_block_w_none(V)}=1, timestep(T_step).
:- not {holds(in_tower(B,V),T_step): s_boolean(V)}=1, s_block(B), timestep(T_step).

Queries:
% Block b1 is on block b2 at time 0.

% Block b3 is moved onto block b4 at time 3.

% At time step 6, block b4 is on b3, b3 is on b2, and b2 is on b1.

ASP form:
% initially, block b1 is on block b2 at time 0.
holds(loc(b1,b2),0).

% block b3 is moved onto block b4 at time 3.
:- not occurs(move(b3),b4),3).

% At time step 6, block b4 is on b3, b3 is on b2, and b2 is on b1.
:- not holds(loc(b4,b3),0).
:- not holds(loc(b3,b2),0).
:- not holds(loc(b2,b1),0).

Program 2:
ASP Domain:
% supersorts
% No supersorts in this domain

% sorts
s_boolean(true;false).
s_switch(s1;s2).
s_switch_direction(up;down).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(status(S,V),0)} :- s_switch(S), s_switch_direction(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(flip(S),T_step)} :- s_switch(S), timestep(T_step).

% Inertia
{holds(status(S,V),T_step+1)} :-holds(status(S,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(status(S,V),T_step): s_switch_direction(V)}=1, s_switch(S), timestep(T_step).

Queries:
% The switch s1 is on at time step 0.
% The switch s2 is on at time step 3.

ASP form:

% The switch s1 is on at time step 0.
holds(status(s1,up),0).

% The switch s2 is on at time step 3.
holds(status(s2,up),3).","


% Flipping a switch changes its status.
% If a switch is flipped to 'up', the other switch must be 'down'.
% If a switch is flipped to 'down', the other switch can be either 'up' or 'down'.
% It is not permissible to flip a switch that is already in the intended direction.
% It is not permissible to flip both switches at the same time.


:- sorts
    switch;
    switch_direction.
:- objects
    s1,s2 :: switch;
    up,down :: switch_direction.
:- variables
    S, S1, S2 :: switch;
    SD, SD1, SD2 :: switch_direction.
:- constants
    status(switch) :: inertialFluent(switch_direction);
    flip(switch) :: action.


% supersorts
% No supersorts in this domain

% sorts
s_boolean(true;false).
s_switch(s1;s2).
s_switch_direction(up;down).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(status(S,V),0)} :- s_switch(S), s_switch_direction(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(flip(S),T_step)} :- s_switch(S), timestep(T_step).

% Inertia
{holds(status(S,V),T_step+1)} :-holds(status(S,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(status(S,V),T_step): s_switch_direction(V)}=1, s_switch(S), timestep(T_step).


% Flipping a switch changes its status.
flip(S) causes status(S)=up if status(S)=down.
flip(S) causes status(S)=down if status(S)=up.

% If a switch is flipped to 'up', the other switch must be 'down'.
flip(S1) causes status(S2)=down if status(S1)=up & S1\=S2.

% If a switch is flipped to 'down', the other switch can be either 'up' or 'down'.
% This is already covered by the default behavior of the switches and does not need a specific rule.

% It is not permissible to flip a switch that is already in the intended direction.
nonexecutable flip(S) if status(S)=up.
nonexecutable flip(S) if status(S)=down.

% It is not permissible to flip both switches at the same time.
nonexecutable flip(S1) & flip(S2).


% Flipping a switch changes its status.
status(S)=up after flip(S) if status(S)=down.
status(S)=down after flip(S) if status(S)=up.

% If a switch is flipped to 'up', the other switch must be 'down'.
status(S2)=down after flip(S1) if status(S1)=up & S1\=S2.

% It is not permissible to flip a switch that is already in the intended direction.
false after flip(S) if status(S)=up.
false after flip(S) if status(S)=down.

% It is not permissible to flip both switches at the same time.
false if flip(S1) & flip(S2).


% Flipping a switch changes its status.
holds(status(S,up),T_step+1) :- occurs(flip(S),T_step), holds(status(S,down),T_step), s_switch(S), timestep(T_step).
holds(status(S,down),T_step+1) :- occurs(flip(S),T_step), holds(status(S,up),T_step), s_switch(S), timestep(T_step).

% If a switch is flipped to 'up', the other switch must be 'down'.
holds(status(S2,down),T_step+1) :- occurs(flip(S1),T_step), holds(status(S1,up),T_step), S1!=S2, s_switch(S1), s_switch(S2), timestep(T_step).

% It is not permissible to flip a switch that is already in the intended direction.
:- occurs(flip(S),T_step), holds(status(S,up),T_step), s_switch(S), timestep(T_step).
:- occurs(flip(S),T_step), holds(status(S,down),T_step), s_switch(S), timestep(T_step).

% It is not permissible to flip both switches at the same time.
:- occurs(flip(S1),T_step), occurs(flip(S2),T_step), s_switch(S1), s_switch(S2), timestep(T_step).


% The switch s1 is on at time step 0.
holds(status(s1,up),0).

% The switch s2 is on at time step 3.
holds(status(s2,up),3).",":- sorts
    switch;
    switch_direction.
:- objects
    s1,s2 :: switch;
    up,down :: switch_direction.
:- variables
    S, S1, S2 :: switch;
    SD, SD1, SD2 :: switch_direction.
:- constants
    status(switch) :: inertialFluent(switch_direction);
    flip(switch) :: action.


% Flipping a switch changes its status.
flip(S) causes status(S)=up if status(S)=down.
flip(S) causes status(S)=down if status(S)=up.

% If a switch is flipped to 'up', the other switch must be 'down'.
flip(S1) causes status(S2)=down if status(S1)=up & S1\=S2.

% If a switch is flipped to 'down', the other switch can be either 'up' or 'down'.
% This is already covered by the default behavior of the switches and does not need a specific rule.

% It is not permissible to flip a switch that is already in the intended direction.
nonexecutable flip(S) if status(S)=up.
nonexecutable flip(S) if status(S)=down.

% It is not permissible to flip both switches at the same time.
nonexecutable flip(S1) & flip(S2).","% supersorts
% No supersorts in this domain

% sorts
s_boolean(true;false).
s_switch(s1;s2).
s_switch_direction(up;down).

% choice rule {0:A} for every atom A containing a regular fluent constant
{holds(status(S,V),0)} :- s_switch(S), s_switch_direction(V).

% choice rule {i:a} for every action constant a and every i < l
{occurs(flip(S),T_step)} :- s_switch(S), timestep(T_step).

% Inertia
{holds(status(S,V),T_step+1)} :-holds(status(S,V),T_step), timestep(T_step).

% existence and uniqueness of value constraint
:- not {holds(status(S,V),T_step): s_switch_direction(V)}=1, s_switch(S), timestep(T_step).


% Flipping a switch changes its status.
holds(status(S,up),T_step+1) :- occurs(flip(S),T_step), holds(status(S,down),T_step), s_switch(S), timestep(T_step).
holds(status(S,down),T_step+1) :- occurs(flip(S),T_step), holds(status(S,up),T_step), s_switch(S), timestep(T_step).

% If a switch is flipped to 'up', the other switch must be 'down'.
holds(status(S2,down),T_step+1) :- occurs(flip(S1),T_step), holds(status(S1,up),T_step), S1!=S2, s_switch(S1), s_switch(S2), timestep(T_step).

% It is not permissible to flip a switch that is already in the intended direction.
:- occurs(flip(S),T_step), holds(status(S,up),T_step), s_switch(S), timestep(T_step).
:- occurs(flip(S),T_step), holds(status(S,down),T_step), s_switch(S), timestep(T_step).

% It is not permissible to flip both switches at the same time.
:- occurs(flip(S1),T_step), occurs(flip(S2),T_step), s_switch(S1), s_switch(S2), timestep(T_step).


% The switch s1 is on at time step 0.
holds(status(s1,up),0).

% The switch s2 is on at time step 3.
holds(status(s2,up),3)."
